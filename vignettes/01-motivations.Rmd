---
title: "01 - Motivations for cpp4r"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{01 - Motivations for cpp4r}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
editor:
  markdown:
    wrap: sentence
bibliography: ["references.bib"]
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Motivation and significance

The R programming language has maintained a long-standing tradition of interfacing with compiled languages, dating back
to the original S implementation in the late 1970s, which served primarily as a wrapper around FORTRAN routines
[@chambers06]. This integration remains relevant today, as R code sometimes lacks the performance needed for
computationally intensive tasks. Even after optimizing R code through vectorization and avoiding unnecessary object
copying, bottlenecks may persist that require compiled language solutions.

C++ offers particular advantages for addressing common R performance bottlenecks, including:

- Loops that cannot be easily vectorized due to dependencies between iterations
- Recursive functions or problems requiring many function calls
- Data structures and algorithms not natively available in R (e.g., R does not let the end-user use pointers and
  pass-by-reference semantics)
- Problems requiring fine-tuning memory management

cpp4r is an R package that provides C++11 bindings to R, enabling the use of C++ code in R packages. It is a fork of the
cpp11 package [@cpp1125] aiming to provide additional features and improvements while maintaining compatibility with the
original cpp11 API.

The landscape of C++ bindings for R has evolved significantly over the past two decades. The cxx package, released in
2000, provided an early prototype of C++ bindings [@hornik01]. Rcpp, first published to CRAN in 2008, became the
mainstream solution with over 2,000 reverse dependencies by 2020 [@eddelbuettel11]. A subsequent attempt, Rcpp11, was
released in 2014 but did not achieve widespread adoption [@francois20].

While Rcpp has been highly successful, adding modern C++ features or addressing certain architectural issues would
require substantial breaking changes to maintain backward compatibility with the extensive ecosystem of dependent
packages.

To address these limitations, the cpp11 package [@cpp1123] was released in 2023 as a reimplementation of C++
bindings to R, incorporating modern C++ features and different design trade-offs aiming to provide:

- Enforced copy-on-write semantics consistent with R's behavior
- Improved safety when interfacing with R's C API
- Native support for ALTREP objects
- UTF-8 string handling throughout
- Modern C++11 features and idioms
- Simplified implementation compared to Rcpp
- Faster compilation with reduced memory requirements
- Completely header-only design to avoid Application Binary Interface (ABI) compatibility issues

## Software description

While using cpp11 to keep my thesis project minimal in terms of code duplication and reusing existing components
instead, I identified several enhancements that could benefit the R community and improve the usability of the library
including:

- Support for converting C++ standard containers (maps) to R lists
- Roxygen documentation support directly in C++ code
- Proper handling of matrix attributes
- Support for nullable external pointers
- Immediate availability of values added via `push_back()`
- Bidirectional copy of complex number types
- Flexibility in type conversions
- Various performance optimizations

After discussing these proposed enhancements with the cpp11 maintainers, it became clear that the development priorities
and timelines would not accommodate these features in the near term. This led to the creation of cpp4r, a fork of cpp11
that incorporates these additional features while maintaining compatibility with the original cpp11 API. This means that
cpp4r can serve as a drop-in replacement for cpp11 in any case, allowing users to benefit from the enhancements without
significant code changes. The converse, replacing cpp4r with cpp11, requires adjustments due to the additional features
in cpp4r.

cpp4r extends cpp11's container support by enabling seamless conversion between C++ standard library containers and R
objects. This includes support for `std::map` and `std::unordered_map` containers, which are automatically converted to
named R lists.

cpp4r provides roxygen support directly in C++ code, allowing developers to document their C++ functions using familiar
roxygen2 syntax. This integration streamlines the documentation workflow for packages that expose C++ functions to R.

Unlike cpp11, cpp4r properly handles matrix attributes, including `dimnames`, ensuring that matrix operations preserve
metadata when copying data between R and C++.

cpp4r offers more flexible type conversion functions. For example, `as_integers()` and `as_doubles()` accept logical
inputs, providing greater flexibility in handling diverse input types compared to the more restrictive cpp11
implementations.

Several internal optimizations improve performance over cpp11, particularly in vector operations and memory management.
These optimizations maintain the safety guarantees of cpp11 while improving execution speed.

cpp4r provides full bidirectional copy of complex numbers, enabling seamless copy of complex vectors and matrices
between R and C++ code. On the contrary, cpp11 does not support copying complex numbers from R to C++ or vice versa.

cpp4r maintains cpp11's core design principles while extending functionality:

- Copy-on-Write Semantics: Like cpp11, cpp4r enforces copy-on-write semantics that match R's behavior, preventing
  unexpected modifications to input data.
- Safety First: cpp4r incorporates comprehensive safety mechanisms when interfacing with R's C API, using
  `unwind_protect()` and exception handling to prevent resource leaks.
- Modern C++ Features: The implementation leverages C++11 features including move semantics, type traits, variadic
  templates, and user-defined literals.
- Header-Only Design: As a completely header-only library, cpp4r avoids ABI compatibility issues that can arise with
  libraries containing compiled components.

cpp4r offers vendoring capabilities, which means that you copy the code for the dependencies into your project's source
tree. This idea comes from the Go programming language, where it is a common practice to included the dependencies'
headers with the source code [@go24]. This ensures the dependency code is fixed and stable until it is updated. This
feature is possible because cpp4r is a header-only library, allowing you to copy all headers  by running
`cpp4r::vendor_cpp4r()` if you need this option.

Vendoring has advantages and drawbacks however. The advantage is that unlikely disruptive changes to the cpp4r project
could never break your existing code. The drawbacks are that the package size will be slightly larger and isolated from
bugfixes and/or new features until you explicitly update the vendored headers. The majority of packages should not
vendor the cpp4r dependency, unless those are designed to run within restricted environments where internet access is
limited or unavailable for security reasons (e.g., high-performance computing clusters).

## Software functionalities

cpp4r is designed as a drop-in replacement for cpp11, using identical syntax and API patterns. Existing cpp11 code can
typically be migrated to cpp4r with minimal changes, primarily involving header includes and namespace references.

To use cpp4r, users must first install the package from CRAN or GitHub. The following code shows how to install the
package:

```r
install.packages("cpp4r", repos = "https://cran.rstudio.com")

# or
remotes::install_github("pachadotdev/cpp4r")
```

Once installed, users can use the provided package template function to create a new package that uses C++ code. The
package template includes simple examples and all the necessary files to compile the code and install the new R package.
The following code shows how to create a new package:

```r
cpp4r::pkg_template("~/rstats/mypkg")
```

The package skeleton includes standard practices:

```r
# In DESCRIPTION file
LinkingTo: cpp4r

# In R code
#' @useDynLib mypkg, .registration = TRUE
#' @keywords internal
"_PACKAGE"
```

C++ functions are exposed to R using the attribute syntax and documented with roxygen comments:

```cpp
/* roxygen
@title Square of Each Element in 'x'
@param x Numeric vector
@return Numeric vector
@export
*/
[[cpp4r::register]]
cpp4r::doubles my_square(cpp4r::doubles x) {
  return x * x;
}
```

The equivalent cpp11 code would be:

```cpp
[[cpp11::register]]
cpp11::doubles my_square_cpp(cpp11::doubles x) {
  return x * x;
}
```

```r
#' @title Square of Each Element in 'x
#' @param x Numeric vector
#' @return Numeric vector
#' @export
my_square <- function(x) {
  my_square_cpp(x)
}
```

## Illustrative examples

cpp4r uses a custom double linked list data structure to track objects it is managing. This structure is more efficient
for large numbers of objects than using `R_PreserveObject()`/`R_ReleaseObjects()` as it is done in Rcpp.

For problems where we know the vectors or matrices size beforehand, the performance difference between cpp4r/cpp11
and Rcpp is negligible. However, when the length of the vectors (or matrices) is not known beforehand, the performance
changes notably, and such is the case of the rejection sampling algorithm which consists in obtaining $n$ accepted
samples without the possibility to know beforehand how many candidates we need to generate.

The C++ `push_back()` method is ideal for cases such as rejection sampling, each candidate is either accepted (stored)
or rejected (discarded), and in a low acceptance rates we might need to generate $kn$ candidates ($k > 1$) than the
$n$ final samples. Unlike Gibbs sampling algorithms, where we know the iterations upfront, rejection sampling genuinely
requires dynamic growth vectors or matrices. For example, with an acceptance rate of 80%, we would need to generate
approximately $1.25 n$ samples to obtain $n$ final samples.

Rejection sampling is used in Monte Carlo methods, Bayesian inference, and simulation studies where cpp4r design is
handy as it reserves extra memory making `push_back()` operations within it have a time complexity $O(1)$. On the
contrary, Rcpp does not reserve extra capacity and its `push_back()` operations have a time complexity $O(n)$ that
leads to a quadratic pattern in memory usage with the number of input elements. This design difference translates in
performance differences with larger input data.

The following code shows a rejection sampling implementation with lower and upper truncation bounds using cpp4r (it is
equivalent for cpp11 and Rcpp):

```cpp
// Reproducible examples via set.seed() in R
class local_rng {
 public:
  local_rng() { GetRNGstate(); }
  ~local_rng() { PutRNGstate(); }
};

[[cpp4r::register]] doubles rejection_sampling_cpp4r(int n_samples, double mu = 0.0, 
                                                     double sigma = 1.0,
                                                     double lower = -2.0, 
                                                     double upper = 2.0) {
  local_rng rng_state;
  
  // Acceptance rate for better initial allocation
  double z_lower = (lower - mu) / sigma, z_upper = (upper - mu) / sigma;
  double acceptance_rate = Rf_pnorm5(z_upper, 0.0, 1.0, 1, 0) -
    Rf_pnorm5(z_lower, 0.0, 1.0, 1, 0);
  
  // Allocate based on expected number of samples needed (add 20% to ensure minimum size)
  R_xlen_t estimated_needed = static_cast<R_xlen_t>(n_samples / acceptance_rate * 1.2);
  estimated_needed = std::max(estimated_needed, static_cast<R_xlen_t>(n_samples));
  
  writable::doubles accepted_samples;
  accepted_samples.reserve(estimated_needed);
  
  // Keep sampling until we have enough accepted samples
  int target_samples = static_cast<int>(n_samples);
  
  while (static_cast<int>(accepted_samples.size()) < target_samples) {
    double candidate = Rf_rnorm(mu, sigma);
    
    if (candidate >= lower && candidate <= upper) {
      accepted_samples.push_back(candidate);
    }
  }
  
  return accepted_samples;
}
```

The following table shows the speed quantiles for the same rejection sampling algorithm implemented with cpp4r, cpp11,
and Rcpp:

```{r}
library(dplyr)
library(purrr)
library(scales)
library(bench)
library(kableExtra)

rejection_bench <- readRDS("rejection_bench.rds")

rejection_bench <- rejection_bench %>%
  select(expression, len, median, mem_alloc) %>%
  mutate(
    expression = as.character(expression),
    len = formatC(len, format = "d", big.mark = ",")
  ) %>%
  mutate(
    expression = factor(expression, levels = c("cpp4r", "cpp11", "Rcpp")),
    len = factor(len, levels = c("25,000", "50,000", "75,000", "100,000")),
  ) %>%
  arrange(expression, len)

rejection_bench %>%
  knitr::kable(align = c("l", rep("r", 3)), booktabs = TRUE,
    col.names = c("Backend", "Sample size", "Median speed", "Cumulative memory usage")) %>%
  kable_styling(latex_options = c("hold_position")) %>%
  collapse_rows(columns = 1, valign = "middle", latex_hline = "major")
```

The benchmark reveals that both cpp4r and cpp11 exhibit better scaling compared to Rcpp, showing how a different
approach makes a difference when we require repeated calls to `push_back()`, as with Rcpp the entire vector has to be
copied on each call. In contrast `cpp4r` vectors grow efficiently, reserving extra space as `std::vector` does.

## Impact

By providing a portable interface for C++ integration, cpp4r enables R developers to leverage the power of modern C++
while minimizing the complexity typically associated with writing compiled code. The benchmarks demonstrate substantial
speed and memory usage improvements compared to existing implementations, providing researchers with a useful tool to
write R packages to analyze large datasets and intensive computations.

Besides the better use of RAM, which can make a difference between being able to run an analysis or not, cpp4r's design
also offers faster compilation times, which can significantly enhance the development workflow and testing. This is
particularly beneficial in academic and business settings, where prototyping and iteration often precede the final
implementation.

cpp4r represents an evolution in C++ bindings for R, building upon the solid foundation established by cpp11 while
addressing specific limitations and adding features that can benefit the R community. By maintaining API compatibility
with cpp11, cpp4r provides a migration path for developers seeking enhanced functionality without requiring significant
code restructuring.

## Conclusion

The development of cpp4r demonstrates the value of open-source transparency and how it enabled derived works. While
cpp11 and Rcpp continue to serve the broader R community effectively, cpp4r offers an alternative for projects
requiring its specific enhancements, particularly in academic research contexts where documentation features and
additional data types support reduces the coding effort for advancing computational methods.


# References
