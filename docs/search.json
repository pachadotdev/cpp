[
  {
    "title": "register",
    "url": "reference/register.html",
    "content": "register Generates wrappers for registered C++ functions register(path = NULL, quiet = !is_interactive(), extension = c(\".cpp\", \".cc\")) pathThe path to the package root directory. The default is NULL, quiet If TRUE suppresses output from this function extension The file extension to use for the generated src/cpp4r file. .cpp by default, but .cc is also supported. The paths to the generated R and C++ source files (in that order). Functions decorated with [[cpp4r::register]] in files ending in .cc, .cpp, .h or .hpp will be wrapped in generated code and registered to be called from R. Note registered functions will not be exported from your package unless you also add a @export roxygen2 directive for them. In order to use register() the cli, decor, desc, glue, tibble and vctrs packages must also be installed. # create a minimal package dir <- tempfile() dir.create(dir) writeLines(\"Package: testPkg\", file.path(dir, \"DESCRIPTION\")) writeLines(\"useDynLib(testPkg, .registration = TRUE)\", file.path(dir, \"NAMESPACE\")) # create a C++ file with a decorated function dir.create(file.path(dir, \"src\")) writeLines(\"[[cpp4r::register]] int one() return 1; \", file.path(dir, \"src\", \"one.cpp\")) # register the functions in the package register(dir) # Files generated by registration file.exists(file.path(dir, \"R\", \"cpp4r.R\")) file.exists(file.path(dir, \"src\", \"cpp4r.cpp\")) # cleanup unlink(dir, recursive = TRUE)",
    "type": "function"
  },
  {
    "title": "pkg_template",
    "url": "reference/pkg_template.html",
    "content": "pkg_template Start a new project with the cpp4r package template pkg_template(path = NULL, pkgname = NULL) pathPath to the new project pkgname Name of the new package The file path to the copied template (invisibly). Start a new project with the cpp4r package template # create a new directory dir <- tempdir() dir.create(dir) # copy the package template into the directory pkg_template(dir, \"mynewpkg\")",
    "type": "function"
  },
  {
    "title": "unvendor",
    "url": "reference/unvendor.html",
    "content": "unvendor Unvendor the cpp4r headers unvendor(path = NULL) pathThe directory with the vendored headers. It is recommended to use \"./src/vendor\". The default is NULL. The path to the unvendored code (invisibly). This function removes the vendored cpp4r headers from your package by automatically finding the vendored headers. # create a new directory dir <- paste0(tempdir(), \"/\", gsub(\"\\\\\\+|[[:punct:]]\", \"\", Sys.time())) dir.create(dir, recursive = TRUE) # vendor the cpp4r headers into the directory vendor(dir) # unvendor the cpp4r headers from the directory unvendor(dir) # cleanup unlink(dir, recursive = TRUE)",
    "type": "function"
  },
  {
    "title": "vendor",
    "url": "reference/vendor.html",
    "content": "vendor Vendor the cpp4r headers vendor(path = \"./src/vendor\") pathThe directory to vendor the headers into The path to the vendored code (invisibly). Vendoring is the act of making your own copy of the 3rd party packages your project is using. It is often used in the go language community. This function vendors cpp4r into your package by copying the cpp4r headers into the inst/include folder of your package and adding 'cpp4r version: XYZ' to the top of the files, where XYZ is the version of cpp4r currently installed on your machine. Note: vendoring places the responsibility of updating the code on you. Bugfixes and new features in cpp4r will not be available for your code until you run cpp_vendor() again. # create a new directory dir <- paste0(tempdir(), \"/\", gsub(\"\\\\\\+|[[:punct:]]\", \"\", Sys.time())) dir.create(dir, recursive = TRUE) # vendor the cpp4r headers into the directory vendor(dir) list.files(dir, recursive = TRUE) # cleanup unlink(dir, recursive = TRUE)",
    "type": "function"
  },
  {
    "title": "01 - Motivations for cpp4r",
    "url": "vignettes/01-motivations.html",
    "content": "knitr::opts_chunk$set( collapse = TRUE, comment = \"#>\" ) Motivation and significance The R programming language has maintained a long-standing tradition of interfacing with compiled languages, dating back to the original S implementation in the late 1970s, which served primarily as a wrapper around FORTRAN routines [@chambers06]. This integration remains relevant today, as R code sometimes lacks the performance needed for computationally intensive tasks. Even after optimizing R code through vectorization and avoiding unnecessary object copying, bottlenecks may persist that require compiled language solutions. C++ offers particular advantages for addressing common R performance bottlenecks, including: - Loops that cannot be easily vectorized due to dependencies between iterations - Recursive functions or problems requiring many function calls - Data structures and algorithms not natively available in R (e.g., R does not let the end-user use pointers and pass-by-reference semantics) - Problems requiring fine-tuning memory management cpp4r is an R package that provides C++11 bindings to R, enabling the use of C++ code in R packages. It is a fork of the cpp11 package [@cpp1125] aiming to provide additional features and improvements while maintaining compatibility with the original cpp11 API. The landscape of C++ bindings for R has evolved significantly over the past two decades. The cxx package, released in 2000, provided an early prototype of C++ bindings [@hornik01]. Rcpp, first published to CRAN in 2008, became the mainstream solution with over 2,000 reverse dependencies by 2020 [@eddelbuettel11]. A subsequent attempt, Rcpp11, was released in 2014 but did not achieve widespread adoption [@francois20]. While Rcpp has been highly successful, adding modern C++ features or addressing certain architectural issues would require substantial breaking changes. These changes would compromise backward compatibility with the extensive ecosystem of dependent packages. To address these limitations, the cpp11 package [@cpp1123] was released in 2023 as a complete reimplementation of C++ bindings to R, incorporating modern C++ features and different design trade-offs aiming to provide: - Enforced copy-on-write semantics consistent with R's behavior - Improved safety when interfacing with R's C API - Native support for ALTREP objects - UTF-8 string handling throughout - Modern C++11 features and idioms - Simplified implementation compared to Rcpp - Faster compilation with reduced memory requirements - Completely header-only design to avoid Application Binary Interface (ABI) compatibility issues Software description While using cpp11 for my thesis project, I identified several enhancements that could benefit the R community and improve the library's usability. These enhancements include: - Support for converting C++ maps to R lists - Roxygen documentation support directly in C++ code - Proper handling of matrix attributes - Support for nullable external pointers - Immediate availability of values added via push_back() - Bidirectional copy of complex number types - Flexibility in type conversions - Various performance optimizations After discussing these proposed enhancements with the cpp11 maintainers, it became clear that the development priorities and timelines would not accommodate these features in the near term. This led to the creation of cpp4r, a fork of cpp11 that incorporates these additional features while maintaining compatibility with the original cpp11 API. This means that cpp4r can serve as a drop-in replacement for cpp11 in any case, allowing users to benefit from the enhancements without significant code changes. The converse, replacing cpp4r with cpp11, requires adjustments due to the additional features in cpp4r. cpp4r extends cpp11's container support by enabling seamless conversion between C++ standard library containers and R objects. This includes support for std::map and std::unordered_map containers, which are automatically converted to named R lists. cpp4r provides roxygen support directly in C++ code, allowing developers to document their C++ functions using familiar roxygen2 syntax. This integration streamlines the documentation workflow for packages that expose C++ functions to R. Unlike cpp11, cpp4r properly handles matrix attributes, including dimnames, ensuring that matrix operations preserve metadata when copying data between R and C++. cpp4r offers more flexible type conversion functions. For example, as_integers() and as_doubles() accept logical inputs, providing greater flexibility in handling diverse input types compared to the more restrictive cpp11 implementations. Several internal optimizations improve performance over cpp11, particularly in vector operations and memory management. These optimizations maintain the safety guarantees of cpp11 while improving execution speed. cpp4r provides full bidirectional copying of complex numbers, enabling seamless transfer of complex vectors and matrices between R and C++ code. In contrast, cpp11 does not support this functionality. cpp4r maintains cpp11's core design principles while extending functionality: - Copy-on-Write Semantics: Like cpp11, cpp4r enforces copy-on-write semantics that match R's behavior, preventing unexpected modifications to input data. - Safety First: cpp4r incorporates comprehensive safety mechanisms when interfacing with R's C API, using unwind_protect() and exception handling to prevent resource leaks. - Modern C++ Features: The implementation leverages C++11 features including move semantics, type traits, variadic templates, and user-defined literals. - Header-Only Design: As a completely header-only library, cpp4r avoids ABI compatibility issues that can arise with libraries containing compiled components. cpp4r offers vendoring capabilities, which means copying the dependency code directly into your project's source tree. This approach, borrowed from the Go programming language, includes the dependencies' headers with the source code [@go24]. This ensures the dependency code remains fixed and stable until explicitly updated. Since cpp4r is a header-only library, you can copy all headers by running cpp4r::vendor_cpp4r() when needed. Vendoring has both advantages and drawbacks. The main advantage is that disruptive changes to the cpp4r project cannot break your existing code. The drawbacks include slightly larger package size and isolation from bugfixes and new features until you explicitly update the vendored headers. Most packages should not vendor the cpp4r dependency, except for projects designed to run in restricted environments where internet access is limited or unavailable for security reasons (e.g., high-performance computing clusters). Software functionalities cpp4r is designed as a drop-in replacement for cpp11, using identical syntax and API patterns. Existing cpp11 code can typically be migrated to cpp4r with minimal changes, primarily involving header includes and namespace references. To use cpp4r, users must first install the package from CRAN or GitHub. The following code shows how to install the package: ``r install.packages(\"cpp4r\", repos = \"https://cran.rstudio.com\") or remotes::install_github(\"pachadotdev/cpp4r\") Once installed, users can use the provided package template function to create a new package that uses C++ code. The package template includes simple examples and all the necessary files to compile the code and install the new R package. The following code shows how to create a new package: `r cpp4r::pkg_template(\"~/rstats/mypkg\") The package skeleton includes standard practices: `r In DESCRIPTION file LinkingTo: cpp4r In R code #' @useDynLib mypkg, .registration = TRUE #' @keywords internal \"_PACKAGE\" C++ functions are exposed to R using the attribute syntax and documented with roxygen comments: `cpp / roxygen @title Square of Each Element in 'x' @param x Numeric vector @return Numeric vector @export / [[cpp4r::register]] cpp4r::doubles my_square(cpp4r::doubles x) { return x x; } The equivalent cpp11 code would be: `cpp [[cpp11::register]] cpp11::doubles my_square_cpp(cpp11::doubles x) { return x x; } `r #' @title Square of Each Element in 'x' #' @param x Numeric vector #' @return Numeric vector #' @export my_square <- function(x) { my_square_cpp(x) } Illustrative examples cpp4r uses lists to track managed objects. This approach is more efficient for large numbers of objects than Rcpp's use of R_PreserveObject()/R_ReleaseObjects(). When vector or matrix sizes are known beforehand, the performance difference between cpp4r/cpp11 and Rcpp is negligible. However, when the length is unknown beforehand, performance changes notably. This is the case with rejection sampling algorithms, which obtain $n$ accepted samples without knowing in advance how many candidates need to be generated. The C++ push_back() method is ideal for rejection sampling, where each candidate is either accepted (stored) or rejected (discarded). With low acceptance rates, we might need to generate $kn$ candidates ($k > 1$) to obtain $n$ final samples. Unlike Gibbs sampling algorithms, where iterations are known upfront, rejection sampling requires dynamically growing vectors or matrices. For example, with an 80% acceptance rate, we need to generate approximately $1.25n$ samples to obtain $n$ final samples. Rejection sampling is used in Monte Carlo methods, Bayesian inference, and simulation studies where cpp4r's design is advantageous because it reserves extra memory, making push_back() operations have $O(1)$ time complexity. In contrast, Rcpp does not reserve extra capacity, and its push_back() operations have $O(n)$ time complexity, leading to quadratic memory usage patterns. This design difference translates to performance differences with larger input data. The following code shows a rejection sampling implementation with lower and upper truncation bounds using cpp4r. The syntax is equivalent for cpp11 and Rcpp, but performance differs: `cpp // Reproducible examples via set.seed() in R class local_rng { public: local_rng() { GetRNGstate(); } ~local_rng() { PutRNGstate(); } }; [[cpp4r::register]] doubles rejection_sampling(int n_samples, double mu = 0.0, double sigma = 1.0, double lower = -2.0, double upper = 2.0) { local_rng rng_state; // Acceptance rate for better initial allocation double z_lower = (lower - mu) / sigma, z_upper = (upper - mu) / sigma; double acceptance_rate = Rf_pnorm5(z_upper, 0.0, 1.0, 1, 0) - Rf_pnorm5(z_lower, 0.0, 1.0, 1, 0); // Allocate based on expected number of samples needed // (add 20% to ensure minimum size) R_xlen_t estimated_needed = static_cast<R_xlen_t>(n_samples / acceptance_rate * 1.2); estimated_needed = std::max(estimated_needed, static_cast<R_xlen_t>(n_samples)); writable::doubles accepted_samples; accepted_samples.reserve(estimated_needed); // Keep sampling until we have enough accepted samples int target_samples = static_cast<int>(n_samples); while (static_cast<int>(accepted_samples.size()) < target_samples) { double candidate = Rf_rnorm(mu, sigma); if (candidate >= lower && candidate <= upper) { accepted_samples.push_back(candidate); } } return accepted_samples; } The following table shows the speed quantiles for the same rejection sampling algorithm implemented with cpp4r, cpp11, and Rcpp: #| label: ch1-tbl-speed #| tbl-cap: \"Median speed and cumulative memory usage for the same rejection sampling algorithm written with different C++ backends for R (cpp11, cpp4r, and Rcpp). Source: own creation.\" #| message: false #| warning: false #| echo: false library(dplyr) library(purrr) library(scales) library(bench) library(kableExtra) rejection_bench <- readRDS(\"rejection_bench.rds\") rejection_bench <- rejection_bench %>% select(expression, len, median, mem_alloc) %>% mutate( expression = as.character(expression), len = formatC(len, format = \"d\", big.mark = \",\") ) %>% mutate( expression = factor(expression, levels = c(\"cpp4r\", \"cpp11\", \"Rcpp\")), len = factor(len, levels = c(\"25,000\", \"50,000\", \"75,000\", \"100,000\")), ) %>% arrange(expression, len) rejection_bench %>% knitr::kable( align = c(\"l\", rep(\"r\", 3)), booktabs = TRUE, col.names = c(\"Backend\", \"Sample size\", \"Median speed\", \"Cumulative memory usage\") ) %>% kable_styling(latex_options = c(\"hold_position\")) %>% collapse_rows(columns = 1, valign = \"middle\") The benchmark shows that both cpp4r and cpp11 scale better than Rcpp when making repeated push_back() calls. With Rcpp, the entire vector must be copied on each call. In contrast, cpp4r vectors grow efficiently by reserving extra space, similar to std::vector`. The benchmark followed the guidelines from @beyer19. It was conducted on a Lenovo ThinkPad X1 Carbon Gen 9 laptop equipped with an 11th Gen Intel Core i7-1185G7 processor (8 cores, 3.00GHz), 15.3 GiB of RAM and Manjaro Linux operating system. Impact By providing a portable interface for C++ integration, cpp4r enables R developers to leverage the power of modern C++ while minimizing the complexity typically associated with writing compiled code. The benchmarks demonstrate substantial speed and memory usage improvements compared to existing implementations, providing researchers with a useful tool to write R packages to analyze large datasets and intensive computations. Beyond improved memory usage, which can determine whether an analysis is feasible, cpp4r's design also offers faster compilation times, enhancing development workflow and testing. This is particularly beneficial in academic and business settings, where prototyping and iteration are common before final implementation. cpp4r represents an evolution in C++ bindings for R, building upon the solid foundation established by cpp11 while addressing specific limitations and adding features that can benefit the R community. By maintaining API compatibility with cpp11, cpp4r provides a migration path for developers seeking enhanced functionality without requiring significant code restructuring. Conclusion The development of cpp4r demonstrates the value of open-source transparency and how it enables derived works. While cpp11 and Rcpp continue to serve the broader R community effectively, cpp4r offers an alternative for projects requiring its specific enhancements, particularly in academic research contexts where documentation features and additional data types support reduce the coding effort for advancing computational methods. The software, documentation, and replication code are available on GitHub. The codebase is released under the Apache 2.0 license. Contributions and feedback from the R community are welcome to help improve the package further. We hope that cpp4r will be a valuable tool for R developers, providing a simple solution for performance bottlenecks by integrating C++ code into R packages. references",
    "type": "vignette"
  },
  {
    "title": "02 - Setup",
    "url": "vignettes/02-setup.html",
    "content": "C++ Setup You will need a working C++ compiler capable of compiling C++11 code. To get it: - On Windows, install Rtools. - On Mac, install Xcode from the App Store. - On Linux, sudo pacman -Syu install build-essential g++-11 or similar. For Ubuntu Users After installing g++-11, you may still encounter issues compiling C++ code due to missing standard library headers. This does not happen when testing on Manjaro Linux. You can try this: ``bash sudo apt install build-essential g++-11 libc++-11-dev libc++abi-11-dev Then you can attempt to compile a simple example to print a number: `cpp // save this as 01-print-number.cpp or similar #include <iostream> // required for the cout function // function to print a message int main() { std::cout << 1 << std::endl; return 0; } Then try to compile and run it with the following bash instruction: `bash g++ 01-print-number.cpp ./01-print-number prints \"1\" Otherwise, not installing the additional packages may lead to the following error: `bash fatal error: 'cstdio' file not found fatal error: 'vector' file not found cannot find -lc++abi: No such file or directory R Setup You can install the R packages bench, cpp4r, devtools and usethis with the following command: `r install.packages(c(\"bench\", \"cpp4r\", \"devtools\", \"usethis\")) To verify that R can compile C++ code, you can run pkgbuild::check_build_tools(debug = TRUE), which will return an output similar to: ``r Trying to compile a simple C file Running /usr/lib64/R/bin/R CMD SHLIB foo.c using C compiler: ‘gcc (GCC) 15.2.1 20250813’",
    "type": "vignette"
  },
  {
    "title": "03 - Package Skeleton",
    "url": "vignettes/03-package-skeleton.html",
    "content": "The reference for this vignette is @usethis24. Loading the Required R Packages This vignette and the next use the following R packages: ``r library(cpp4r) library(devtools) library(bench) library(usethis) Creating a Dummy Package You can create a new package in RStudio (or VSCode) by running: `r pkg_template(\"~/github/cpp4r/cpp4rexamples\") This command will create a new folder containing the cpp4rexamples package. Afterward, you can run use_cpp4r() to add the necessary code to the package. Print a Number The pkg_template() function automatically creates ./cpp4rexamples/R/cpp4rexamples-package.R with the following content: `r #' @useDynLib cpp4rexamples, .registration = TRUE #' @keywords internal \"_PACKAGE\" It also creates ./cpp4rexamples/src/main.cpp. The rest of src/ aims to provide an organization to keep the code organized into different files according to their purpose. Give a look at ./cpp4rexamples/src/01_plus_one.h, which contains the following C++ code: `cpp / roxygen @title Plus 1 (C++) @param x integer @description It adds 1 to an integer value. @export @examples plus_one(1) / [[cpp4r::register]] int plus_one(int x) { return x + 1; } This code is called by main.cpp and it makes sense to keep this organization when the codebase grows, otherwise you can end up with a single large cpp file containing thousands of lines of code that will be harder to maintain. With R packages, there is no need to create a main() function in C++, which is the entry point of a standalone C++ program. Unlike cpp11, cpp4r can document the C++ functions using roxygen2 comments. The comments must be placed before the [[cpp4r::register]] attribute. With cpp11, you would need to write a separate wrapper, like this: `cpp [[cpp4r::register]] int plus_one_(int x) { return x + 1; } `r #' @title Plus 1 (C++) #' @param x integer #' @description It adds 1 to an integer value. #' @export #' @examples plus_one(1) plus_one <- function(x) { plus_one_(x) } The R version of the previous function is as follows: `r #' Plus one (R) #' @param x integer #' @description It adds 1 to an integer value. #' @export #' @examples plus_one_r(1) plus_one_r <- function(x) { x + 1 } To use the C++ function, you can register and document it by running: `r cpp4r::register() devtools::document() devtools::load_all() Which should print: `r > plus_one(1) [1] 2 For development and live testing, you should use the load_all(): `r load_all() Try plus_two(1) and plus_two(1.0). Why does 1 and 1.0 matter in C++? Number's Sign A more complex function is one that returns the sign of a number: `cpp [[cpp4r::register]] int sign_cpp(double x) { if (x > 0) { return 1; } else if (x == 0) { return 0; } else { return -1; } } Add this function to a new file src/03_sign.h. Here is the R version of the function: `r sign_r <- function(x) { if (x > 0) { 1 } else if (x == 0) { 0 } else { -1 } } Do not forget to include the new header file in main.cpp. Document both functions and compare their outputs. Installing the Package To document and install the package as an R library, you can run the following functions: `r cpp4r::register() devtools::document() devtools::install() Afterward, you can access the functions by loading the package with library(cpp4rexamples). Each time you need to make changes to the C++ code, you can run load_all() again to test and then reinstall the package. Good Practice It is good practice to include a license for your code. For example, you can use the Apache license by running: `r usethis::use_apache_license() Additionally, it is recommended to use use_build_ignore() to ignore files that are unnecessary for package installation. For example, to ignore the docs folder, you can run: `r usethis::use_build_ignore(\"docs\") Your .Rbuildignore` file can include the following lines, which you can edit manually to exclude specific files and directories: ^\\.vscode$ ^LICENSE\\.md$ ^cpp4rexamples\\.Rproj$ References",
    "type": "vignette"
  },
  {
    "title": "04 - Read-only versus Writable R Objects",
    "url": "vignettes/04-read-only.html",
    "content": "Read and write In cpp4r, when you declare a variable, it is read-only by default as in cpp11 [@vaughan24]. This is different from Rcpp, where variables are read-write by default [@eddelbuettel11]. Following from the package created in the previous vignette, try to compile and run the following code by adding it to a new file src/04_square_coordinates.h: ``cpp [[cpp4r::register]] integers square_coordinates_(integers x) { integers out = x; for (int i = 0; i < x.size(); ++i) { out[i] = x[i] x[i]; } return out; } devtools::load_all() and devtools::install() will fail with the following error: `bash error: lvalue required as left operand of assignment out[i] = x[i] x[i]; This is because the argument x is a read-only object, you need to explicitly declare a writable variable: `cpp [[cpp4r::register]] integers square_coordinates(integers x) { writable::integers out = x; for (int i = 0; i < x.size(); ++i) { out[i] = x[i] x[i]; } return out; } Alternatively, you can declare the argument as writable: `cpp [[cpp4r::register]] integers square_coordinates_2(writable::integers x) { for (int i = 0; i < x.size(); ++i) { x[i] = x[i] x[i]; } return x; } Do not forget to include the new header file in main.cpp: Document these functions with roxygen and compare their outputs after loading the updated package: `r cpp4r::register() devtools::document() devtools::load_all() Compare square_coordinates(1:3), square_coordinates(c(1, 2, 3)), and square_coordinates(c(1L, 2L, 3L)). Why do the outputs differ? Are integers and doubles interchangeable as double and int` in C++ for reasonable cases? References",
    "type": "vignette"
  },
  {
    "title": "05 - Logical Functions",
    "url": "vignettes/05-logical-functions.html",
    "content": "These examples were adapted from @vaughan24. Note These functions ignore NA values for now. Adjustments for handling NA values are covered in a separate vignette. R already provides efficient versions of the functions covered here. This is just to illustrate how to use C++ code. Is any value in a vector 'true'? Base R's any() function returns TRUE if there is at least one TRUE element in a vector, and FALSE otherwise. Below is one possible C++ implementation: knitr::opts_chunk$set(eval = FALSE) ``cpp [[cpp4r::register]] bool any_cpp(logicals x) { int n = x.size(); for (int i = 0; i < n; ++i) { if (x[i]) { return true; } } return false; } Its R equivalent would be: `r any_r <- function(x) { n <- length(x) for (i in 1:n) { if (x[i]) { return(TRUE) } } FALSE } Add and document the functions, update the package as in the previous vignettes, and then compare the functions speed with: install.packages(\"bench\") library(bench) set.seed(123) for reproducibility x <- rpois(1e6, lambda = 2) 1,000,000 elements y <- ifelse(x > 2, TRUE, FALSE) any(y) any_cpp(y) any_r(y) mark( any(y), any_cpp(y), any_r(y) ) Which elements in a vector are 'true'? Base R's which() function returns the indices of the TRUE elements in a vector. Here is a possible C++ implementation: `cpp [[cpp4r::register]] integers which_cpp(logicals x) { int n = x.size(); writable::integers res; int j = 0; for (int i = 0; i < n; ++i) { if (x[i]) { ++j; res.push_back(i + 1); } } if (j == 0) { return integers(0); } else { return res; } } Its R equivalent would be: `r which_r <- function(x) { n <- length(x) res <- c() j <- 0 for (i in 1:n) { if (x[i]) { res <- c(res, i) j <- j + 1 } } if (j == 0) { return(0) } else { return(res) } } To test the functions, you can run the following benchmark code in the R console: which(y[1:100]) which_cpp(y[1:100]) which_r(y[1:100]) mark( which(y[1:1000]), which_cpp(y[1:1000]), which_r(y[1:1000]) ) Are all values in a vector 'true'? Base R's all() function checks if all elements in a vector are TRUE. Here is a possible C++ implementation that loops over the vector: `cpp [[cpp4r::register]] bool all_cpp_1(logicals x) { int n = x.size(); for (int i = 0; i < n; ++i) { if (!x[i]) { return false; } } return true; } More concise C++ alternatives are: `cpp [[cpp4r::register]] bool all_cpp_2(logicals x) { for (int i = 0; i < x.size(); ++i) { if (!x[i]) { return false; } } return true; } [[cpp4r::register]] bool all_cpp_3(logicals x) { for (bool i : x) { if (!i) { return false; } } return true; } [[cpp4r::register]] bool all_cpp_4(logicals x) { return std::all_of(x.begin(), x.end(), [](bool x) { return x; }); } To avoid typing std:: every time, you can use using namespace std; at the top of src/code.cpp. However, this is not recommended because it can lead to conflicts. A better option is to declare using std::the_function; which means you can use the_function instead of std::the_function` each time [@akbiggs24]. However, this is not recommended as it can lead to conflicts if two functions have the same name. To test the functions, you can run the following tests and benchmark code in the R console: set.seed(123) for reproducibility x <- rpois(1e6, lambda = 2) 1,000,000 elements all(x > 2) all_cpp_1(x > 2) all_cpp_2(x > 2) all_cpp_3(x > 2) all_cpp_4(x > 2) also test the TRUE-only case all(x >= 0) all_cpp_1(x >= 0) all_cpp_2(x >= 0) all_cpp_3(x >= 0) all_cpp_4(x >= 0) mark( all(x > 2), all_cpp_1(x > 2), all_cpp_2(x > 2), all_cpp_3(x > 2), all_cpp_4(x > 2) ) References",
    "type": "vignette"
  },
  {
    "title": "06 - Rolling Functions",
    "url": "vignettes/06-rolling-functions.html",
    "content": "These examples were adapted from @vaughan24. Note These functions ignore NA values for now. Adjustments for handling NA values are covered in a separate vignette. R already provides efficient versions of the functions covered here. This is just to illustrate how to use C++ code. Cumulative sum Base R provides the cumsum() function to compute the cumulative sum of a vector: knitr::opts_chunk$set(eval = FALSE) cumsum(1:5) One possible C++ function to implement this is: ``cpp [[cpp4r::register]] doubles cumsum_cpp(doubles x) { int n = x.size(); writable::doubles out(n); out[0] = x[0]; for (int i = 1; i < n; ++i) { out[i] = out[i - 1] + x[i]; } return out; } Its R equivalent would be: `r cumsum_r <- function(x) { n <- length(x) out <- numeric(n) out[1] <- x[1] for (i in 2:n) { out[i] <- out[i - 1] + x[i] } out } Add and document the functions, update the package as in the previous vignettes, and then compare the functions speed with: install.packages(\"bench\") library(bench) set.seed(123) for reproducibility x <- rpois(1e6, lambda = 2) 1,000,000 elements cumsum(1:3) cumsum_cpp(1:3) cumsum_r(1:3) mark( cumsum(x), cumsum_cpp(x), cumsum_r(x) ) Cumulative product Base R provides the cumprod() function to compute the cumulative product of a vector: cumprod(1:5) One possible C++ function to implement this is: `cpp [[cpp4r::register]] doubles cumprod_cpp(doubles x) { int n = x.size(); writable::doubles out(n); out[0] = x[0]; for (int i = 1; i < n; ++i) { out[i] = out[i - 1] x[i]; } return out; } Its R equivalent would be: `r cumprod_r <- function(x) { n <- length(x) out <- numeric(n) out[1] <- x[1] for (i in 2:n) { out[i] <- out[i - 1] x[i] } out } To test the functions, you can run the following benchmark code in the R console: mark( cumprod(x), cumprod_cpp(x), cumprod_r(x) ) Range of values A simple example of the range() function in R is: range(x) One possible C++ function to implement this is: ``cpp [[cpp4r::register]] doubles range_cpp(doubles x) { int n = x.size(); double x1 = x[0], x2 = x[0]; for (int i = 1; i < n; ++i) { x1 = std::min(x1, x[i]); x2 = std::max(x2, x[i]); } writable::doubles out(2); out[0] = x1; out[1] = x2; return out; } Write its R equivalent. To verify the functions, you can run the following tests and benchmark code in the R console: install.packages(\"purrr\") install.packages(\"dplyr\") install.packages(\"ggplot2\") install.packages(\"patchwork\") library(purrr) library(dplyr) library(ggplot2) library(patchwork) range(x) range_cpp(x) range_r(x) create random vectors set.seed(123) for reproducibility bigx <- list( as.double(rpois(2e6, lambda = 2)), as.double(rpois(4e6, lambda = 2)), as.double(rpois(8e6, lambda = 2)), as.double(rpois(16e6, lambda = 2)), as.double(rpois(32e6, lambda = 2)), as.double(rpois(64e6, lambda = 2)) ) results <- map( bigx, ~ mark( range(.x), range_cpp(.x) range_r(.x) ) %>% mutate(n = length(.x)) ) d <- results %>% bind_rows() %>% unnest(c(time, mem_alloc, gc, n)) %>% select(expression, time, mem_alloc, gc, n) g1 <- ggplot(d, aes(x = n, y = time, color = expression)) + geom_jitter(width = 0.01, height = 0.01) + scale_color_viridis_d() + theme_minimal() g2 <- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) + geom_jitter(width = 0.01, height = 0.01) + scale_color_viridis_d() + theme_minimal() g1 / g2 References",
    "type": "vignette"
  },
  {
    "title": "07 - Statistical Functions",
    "url": "vignettes/07-statistical-functions.html",
    "content": "Note These functions ignore NA values for now. Adjustments for handling NA values are covered in a separate vignette. R already provides efficient versions of the functions covered here. This is just to illustrate how to use C++ code. The explanations and equations used for the functions are taken from @diez15 and @hansen22. Some examples were adapted from @vaughan24. Sum For a vector of $n$ elements $x_1, x_2, \\ldots, x_n$, the sum is calculated as: $$ \\sum_{i=1}^{n} x_i = x_1 + x_2 + \\ldots + x_n $$ The following C++ function calculates the sum of a vector's elements: knitr::opts_chunk$set(eval = FALSE) ``cpp [[cpp4r::register]] double sum_cpp(doubles x) { int n = x.size(); double total = 0; for(int i = 0; i < n; ++i) { total += x[i]; } return total; } Its R equivalent is: `r sum_r <- function(x) { total <- 0 for (i in seq_along(x)) { total <- total + x[i] } total } Document the functions and update the package as in the previous vignettes. To test the functions, you can run the following benchmark code in the R console: install.packages(\"bench\") library(bench) set.seed(123) for reproducibility x <- runif(1e3) 1,000,000 elements sum(x) sum_cpp(x) sum_r(x) mark( sum(x), sum_cpp(x), sum_r(x) ) Arithmetic mean The arithmetic mean of a vector of $n$ elements $x_1, x_2, \\ldots, x_n$ is calculated as: $$ \\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i $$ The following C++ function calculates the mean of a vector's elements: `cpp [[cpp4r::register]] double mean_cpp(doubles x) { int n = x.size(); double y = 0; for(int i = 0; i < n; ++i) { y += x[i]; } return y / n; } Its R equivalent would be: `r mean_r <- function(x) { sum_r(x) / length(x) } Document the functions and update the package as in the previous vignettes. To test the functions, you can run the following benchmark code in the R console: mean(x) mean_cpp(x) mean_r(x) mark( mean(x), mean_cpp(x), mean_r(x) ) Variance The variance of a vector of $n$ elements $x_1, x_2, \\ldots, x_n$ is calculated as: $$ \\text{Var}(x) = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2 $$ The following C++ function calculates the variance of a vector's elements: `cpp [[cpp4r::register]] double var_cpp(doubles x) { int n = x.size(); double y1 = 0, y2 = 0; for(int i = 0; i < n; ++i) { y1 += x[i]; y2 += pow(x[i], 2.0); } return (y2 - pow(y1, 2.0) / n) / (n - 1); } Its R equivalent would be: `r var_r <- function(x) { mean_r((x - mean_r(x))^2) } Document the functions and update the package as in the previous vignettes. To test the functions, you can run the following benchmark code in the R console: var(x) var_cpp(x) var_r(x) mark( var(x), var_cpp(x), var_r(x) ) Root Mean Square Error (RMSE) The RMSE function measures the differences between observed values and the true value. For a vector of $n$ elements $x_1, x_2, \\ldots, x_n$ and a value $x_0$, the RMSE is calculated as: $$ \\text{RMSE}(x, x_0) = \\sqrt{\\frac{1}{n} \\sum_{i=1}^{n} (x_i - x_0)^2} $$ The following C++ function calculates the difference of a vector's elements to a value and returns the square root of the mean of the squared differences: `cpp [[cpp4r::register]] double rmse_cpp(doubles x, double x0) { int n = x.size(); double y = 0; for (int i = 0; i < n; ++i) { y += pow(x[i] - x0, 2.0); } return sqrt(y / n); } Its R equivalent would be: ``r #' Return the root mean square error (R) #' @param x numeric vector #' @param x0 numeric value #' @export rmse_r <- function(x, x0) { sqrt(sum((x - x0)^2) / length(x)) } Document the functions and update the package as in the previous vignettes. To test the functions, you can run the following benchmark code in the R console: create a list with 100 normal distributions with mean 0 and 1 million elements set.seed(123) x <- list() for (i in 1:1e3) { x[[i]] <- rnorm(1e3) } compute the mean of each distribution x <- sapply(x, mean) rmse_cpp(x, 0) rmse_r(x, 0) mark( rmse_cpp(x, 0), rmse_r(x, 0) ) References",
    "type": "vignette"
  },
  {
    "title": "08 - Logical Functions with Missing Values",
    "url": "vignettes/08-logical-functions-2.html",
    "content": "Note These functions ignore NA values for now. Adjustments for handling NA values are covered in a separate vignette. R already provides efficient versions of the functions covered here. This is just to illustrate how to use C++ code. Is any value in a vector 'true'? The following function expands the previous any_cpp() function to handle missing values. knitr::opts_chunk$set(eval = FALSE) ``cpp [[cpp4r::register]] bool any2_cpp(logicals x, bool na_rm = false) { int n = x.size(); bool has_na = false; for (int i = 0; i < n; ++i) { if (x[i] == NA_LOGICAL) { has_na = true; if (!na_rm) { continue; // Skip NA values if na_rm is false } } else if (x[i]) { return true; } } // If we found any NA and na_rm is false, return NA if (has_na && !na_rm) { return NA_LOGICAL; } return false; } To test the functions, you can run the following benchmark code in the R console: set.seed(123) for reproducibility x <- rpois(1e6, lambda = 2) 1,000,000 elements y <- ifelse(x > 2, TRUE, FALSE) any(c(TRUE, NA, FALSE)) any2_cpp(c(TRUE, NA, FALSE)) any2_cpp(c(TRUE, NA, FALSE), na_rm = TRUE) mark( any(y), any2_cpp(y) ) Which elements in a vector are 'true'? The following function expands the previous which_cpp() function to handle missing values. `cpp [[cpp4r::register]] integers which2_cpp(logicals x, bool na_rm = false) { int n = x.size(); writable::integers res; int j = 0; for (int i = 0; i < n; ++i) { if (x[i] == NA_LOGICAL) { if (!na_rm) { // Skip NA values if na_rm is false continue; } } else if (x[i]) { ++j; res.push_back(i + 1); } } if (j == 0) { return integers(0); } else { return res; } } To test the functions, you can run the following benchmark code in the R console: which(c(TRUE, NA, FALSE, TRUE)) which2_cpp(c(TRUE, NA, FALSE, TRUE)) which2_cpp(c(TRUE, NA, FALSE, TRUE), na_rm = TRUE) mark( which(y[1:1000]), which2_cpp(y[1:1000]) ) Are all values in a vector 'true'? The following function expands the previous all_cpp() function to handle missing values. `cpp [[cpp4r::register]] bool all2_cpp_1(logicals x, bool na_rm = false) { int n = x.size(); bool has_na = false; for (int i = 0; i < n; ++i) { if (x[i] == NA_LOGICAL) { has_na = true; if (!na_rm) { continue; // Skip NA values if na_rm is false } } else if (!x[i]) { return false; } } // If we found any NA and na_rm is false, return NA if (has_na && !na_rm) { return NA_LOGICAL; } return true; } More concise C++ alternatives are: ``cpp [[cpp4r::register]] bool all2_cpp_2(logicals x, bool na_rm = false) { bool has_na = false; for (int i = 0; i < x.size(); ++i) { if (x[i] == NA_LOGICAL) { has_na = true; if (!na_rm) { continue; } } else if (!x[i]) { return false; } } if (has_na && !na_rm) { return NA_LOGICAL; } return true; } [[cpp4r::register]] bool all2_cpp_3(logicals x, bool na_rm = false) { bool has_na = false; for (int i = 0; i < x.size(); ++i) { if (x[i] == NA_LOGICAL) { has_na = true; if (!na_rm) { continue; } } else if (!x[i]) { return false; } } if (has_na && !na_rm) { return NA_LOGICAL; } return true; } To test the functions, you can run the following tests and benchmark code in the R console: set.seed(123) for reproducibility x <- rpois(1e6, lambda = 2) 1,000,000 elements all(c(TRUE, NA, TRUE)) all2_cpp_1(c(TRUE, NA, TRUE)) all2_cpp_1(c(TRUE, NA, TRUE), na_rm = TRUE) all(c(FALSE, NA, TRUE)) all2_cpp_1(c(FALSE, NA, TRUE)) all2_cpp_1(c(FALSE, NA, TRUE), na_rm = TRUE) also test the TRUE-only case all(x >= 0) all2_cpp_1(x >= 0) all2_cpp_2(x >= 0) all2_cpp_3(x >= 0) mark( all(x > 2), all2_cpp_1(x > 2), all2_cpp_2(x > 2), all2_cpp_3(x > 2) ) References",
    "type": "vignette"
  },
  {
    "title": "09 - Rolling Functions with Missing Values",
    "url": "vignettes/09-rolling-functions-2.html",
    "content": "Note These functions ignore NA values for now. Adjustments for handling NA values are covered in a separate vignette. R already provides efficient versions of the functions covered here. This is just to illustrate how to use C++ code. Cumulative sum The following function expands the previous cumsum_cpp() function to handle missing values. knitr::opts_chunk$set(eval = FALSE) ``cpp [[cpp4r::register]] doubles cumsum2_cpp(doubles x, bool na_rm = false) { int n = x.size(); writable::doubles out(n); out[0] = x[0]; if (na_rm == true) { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y2)) { out[i] = y1 + 0.0; } else { if (ISNAN(y1)) { out[i] = 0.0 + y2; } else { out[i] = y1 + y2; } } } } else { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y2)) { out[i] = NA_REAL; } else { if (ISNAN(y1)) { out[i] = NA_REAL; } else { out[i] = y1 + y2; } } } } return out; } To test the functions, you can run the following benchmark code in the R console: set.seed(123) for reproducibility x <- rpois(1e6, lambda = 2) 1,000,000 elements cumsum(c(1, NA, 2, 4)) cumsum2_cpp(c(1, NA, 2, 4)) cumsum2_cpp(c(1, NA, 2, 4), na_rm = TRUE) mark( cumsum(x), cumsum2_cpp(x) ) Cumulative product The following function expands the previous cumprod_cpp() function to handle missing values. `cpp [[cpp4r::register]] doubles cumprod2_cpp(doubles x, bool na_rm = false) { int n = x.size(); writable::doubles out(n); out[0] = x[0]; if (na_rm == true) { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y2)) { out[i] = y1 1.0; } else { if (ISNAN(y1)) { out[i] = 1.0 y2; } else { out[i] = y1 y2; } } } } else { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y2)) { out[i] = NA_REAL; } else { if (ISNAN(y1)) { out[i] = NA_REAL; } else { out[i] = y1 y2; } } } } return out; } To test the functions, you can run the following benchmark code in the R console: cumprod(c(1, NA, 2, 4)) cumprod2_cpp(c(1, NA, 2, 4)) cumprod2_cpp(c(1, NA, 2, 4), na_rm = TRUE) mark( cumprod(x), cumprod2_cpp(x) ) Cumulative minimum The next function calculates the cumulative minimum of the elements of a vector. `cpp [[cpp4r::register]] doubles cummin_cpp(doubles x, bool na_rm = false) { int n = x.size(); writable::doubles out(n); out[0] = x[0]; if (na_rm == true) { for (int i = 1; i < n; ++i) { double y1 = x[i - 1], y2 = x[i]; if (ISNAN(y1)) { out[i] = y2; } else { out[i] = std::min(y1, y2); } } } else { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y2)) { out[i] = NA_REAL; } else { if (ISNAN(y1)) { out[i] = NA_REAL; } else { out[i] = std::min(y1, y2); } } } } return out; } To test the function, you can run the following benchmark code in the R console: cummin(c(1, NA, 2, 4)) cummin_cpp(c(1, NA, 2, 4)) cummin_cpp(c(1, NA, 2, 4), na_rm = TRUE) mark( cummin(x), cummin_cpp(x) ) Cumulative maximum The next function calculates the cumulative maximum of the elements of a vector. ``cpp [[cpp4r::register]] doubles cummax_cpp(doubles x, bool na_rm = false) { int n = x.size(); writable::doubles out(n); out[0] = x[0]; if (na_rm == true) { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y1)) { out[i] = y2; } else { out[i] = std::max(y1, y2); } } } else { for (int i = 1; i < n; ++i) { double y1 = out[i - 1], y2 = x[i]; if (ISNAN(y2)) { out[i] = NA_REAL; } else { if (ISNAN(y1)) { out[i] = NA_REAL; } else { out[i] = std::max(y1, y2); } } } } return out; } To test the functions, you can run the following benchmark code in the R console: cummax(c(1, NA, 2, 4)) cummax_cpp(c(1, NA, 2, 4)) cummax_cpp(c(1, NA, 2, 4), na_rm = TRUE) mark( cummax(x), cummax_cpp(x) ) References",
    "type": "vignette"
  },
  {
    "title": "10 - Statistical Functions with Missing Values",
    "url": "vignettes/10-statistical-functions-2.html",
    "content": "Note These functions ignore NA values for now. Adjustments for handling NA values are covered in a separate vignette. R already provides efficient versions of the functions covered here. This is just to illustrate how to use C++ code. Sum The following function expands the previous sum_cpp() function to handle missing values. knitr::opts_chunk$set(eval = FALSE) ``cpp [[cpp4r::register]] double sum2_cpp(doubles x, bool na_rm = false) { int n = x.size(); double total = 0; for (int i = 0; i < n; ++i) { if (na_rm && ISNAN(x[i])) { continue; } else { total += x[i]; } } return total; } To test the functions, you can run the following benchmark code in the R console: set.seed(123) for reproducibility x <- runif(1e3) 1,000 elements x[sample(1:1e3, 1e2)] <- NA randomly insert NA values sum(x, na.rm = FALSE) sum2_cpp(x, na_rm = FALSE) sum(x, na.rm = TRUE) sum2_cpp(x, na_rm = TRUE) mark( sum(x, na.rm = TRUE), sum2_cpp(x, na_rm = TRUE) ) Arithmetic mean The following function expands the previous mean_cpp() function to handle missing values. `cpp [[cpp4r::register]] double mean2_cpp(doubles x, bool na_rm = false) { int n = x.size(); int m = 0; for (int i = 0; i < n; ++i) { if (na_rm && ISNAN(x[i])) { continue; } else { ++m; } } if (m == 0) { return NA_REAL; } double total = 0; for (int i = 0; i < n; ++i) { if (na_rm && ISNAN(x[i])) { continue; } else { total += x[i]; } } return total / m; } To test the functions, you can run the following benchmark code in the R console: mean(x) mean2_cpp(x) mean(x, na.rm = TRUE) mean2_cpp(x, na_rm = TRUE) mark( mean(x, na.rm = TRUE), mean2_cpp(x, na_rm = TRUE) ) Variance The following function expands the previous var_cpp() function to handle missing values. `cpp [[cpp4r::register]] double var2_cpp(doubles x, bool na_rm = false) { int n = x.size(); int m = 0; double total = 0, sq_total = 0; for (int i = 0; i < n; ++i) { if (na_rm && ISNAN(x[i])) { continue; } else { ++m; total += x[i]; sq_total += pow(x[i], 2); } } if (m <= 1) { return NA_REAL; } return (sq_total - total * total / m) / (m - 1); } To test the functions, you can run the following benchmark code in the R console: var(x) var2_cpp(x) var(x, na.rm = TRUE) var2_cpp(x, na_rm = TRUE) mark( var(x, na.rm = TRUE), var2_cpp(x, na_rm = TRUE) ) Root Mean Square Error (RMSE) The following function expands the previous rmse_cpp() function to handle missing values. ``cpp [[cpp4r::register]] double rmse2_cpp(doubles x, double x0, bool na_rm = false) { int n = x.size(); int m = 0; double total = 0; for (int i = 0; i < n; ++i) { if (na_rm && ISNAN(x[i])) { continue; } else { ++m; total += pow(x[i] - x0, 2); } } if (m == 0) { return NA_REAL; } return sqrt(total / m); } To test the functions, you can run the following benchmark code in the R console: create a list with 100 normal distributions with mean 0 and 1,000 elements each set.seed(123) x <- list() for (i in 1:1e3) { x[[i]] <- rnorm(1e3) } compute the mean of each distribution x <- sapply(x, mean) insert NA values at random x[sample(1:1e3, 1e2)] <- NA rmse2_cpp(x, 0) rmse2_cpp(x, 0, na_rm = TRUE) mark( sqrt(mean((x - 0)^2, na.rm = TRUE)), rmse2_cpp(x, 0, na_rm = TRUE) ) References",
    "type": "vignette"
  },
  {
    "title": "11 - Debugging R Packages",
    "url": "vignettes/11-debugging.html",
    "content": "Motivation The previous package skeleton left out some essential details, such as testing for memory leaks and debugging. This vignette will cover these aspects in more detail. The references for this vignette are @vaughan24, @rpkgdevel24, @padgham22, @vaughan19, and @wickham19. Compiler Setup To test that your functions do not lead to memory errors, you can create/edit a src/Makevars.in file within the package folder and add: ``bash PKG_CXXFLAGS = -Wall -O0 -pedantic PKG_CPPFLAGS = -UDEBUG -g On Windows, the file is src/Makevars.win and the content is the same. This requires some explanations: -Wall: Enables all warnings. -O0: Disables optimizations for debugging purposes. Otherwise, the compiler will adjust the package compiled binaries for speedups, making it harder to debug. Once your code is working, you can switch to -O2 or -O3 to enable optimizations for production. If you plan to submit the package to CRAN, remove the flag, as they do not accept it. -pedantic: Enforces strict ISO C++ compliance. This will warn about improper writing, similar to bad grammar or spelling errors in English. -UDEBUG -g: Disables the DEBUG macro and enables debugging information. When a package is ready, -g can be removed to reduce the size of the compiled binaries. In case that the \"pedantic\" part is not clear, here is an example: `cpp #include \"cpp4r.hpp\" #include <numeric> using namespace cpp4r; // Non-ISO: Use a variable length array [[cpp4r::register]] double squared_sum_non_iso_(integers inp) { int size = inp.size(); double array[size]; // will give a warning, but still compile for (int i = 0; i < size; ++i) { array[i] = inp[i] inp[i]; } return std::accumulate(array, array + size, 0.0); } // ISO: Use a vector [[cpp4r::register]] double squared_sum_iso_(integers inp) { int size = inp.size(); std::vector<double> vec(size); for (int i = 0; i < size; ++i) { vec[i] = inp[i] inp[i]; } return std::accumulate(vec.begin(), vec.end(), 0.0); } Even when the code compiles, it gives a warning: `bash code.cpp:489:10: warning: ISO C++ forbids variable length array ‘array’ [-Wvla] 489 | double array[size]; // will give a warning, but still compile It is possible to verify that the functions are correct: `r all.equal(sum((1:5)^2), squared_sum_non_iso_(1:5), squared_sum_iso_(1:5)) Testing for Memory Leaks To test for memory leaks, you can use the valgrind tool. This tool is available on Linux and macOS. You can test for memory leaks by running the following command in the terminal: `bash valgrind --leak-check=full Rscript -e \"library(cpp4rexamples); squared_sum_iso_(1:5)\" Or, alternatively, to call R in vanilla mode: `bash R --vanilla -d 'valgrind -s --track-origins=yes' -f test.R with test.R containing: `r library(cpp4rexamples) squared_sum_iso_(1:5) Adding a configure script For a portable package, it is recommended to add a configure script. This script will check for the necessary tools to build the package. The script is written in bash and is placed in the configure file in the package root directory. Here is an example of a configure script for the cpp4rexamples package: `bash #!/bin/sh PKG_CONFIG_NAME=\"gccsanissue\" pkg-config --version >/dev/null 2>&1 if [ $? -eq 0 ]; then PKGCONFIG_CFLAGS=pkg-config --cflags --silence-errors PKGCONFIG_LIBS=pkg-config --libs fi if [ \"$PKGCONFIG_CFLAGS\" ] || [ \"$PKGCONFIG_LIBS\" ]; then echo \"Found pkg-config cflags and libs!\" PKG_CFLAGS=${PKGCONFIG_CFLAGS} PKG_LIBS=${PKGCONFIG_LIBS} fi CXXFLAGS=\"-stdlib=libc++\" CXXFLAGS=\"-O0 -g -stdlib=libc++\" LDFLAGS=\"-stdlib=libc++\" sed -e \"s|@cxxflags@|$CXXFLAGS|\" \\ -e \"s|@ldflags@|$LDFLAGS|\" \\ src/Makevars.in > src/Makevars exit 0 This file, meant for Unix systems, must be accompanied by an configure.win file for Windows systems. Besides the configure script, an src/Makevars.in file must be created. This file is a template for the src/Makevars file. Here is an example: LDFLAGS=@ldflags@ Convert source files to object files SOURCES = code.cpp \\ cpp4r.cpp OBJECTS = $(SOURCES:.cpp=.o) all: $(SHLIB) $(SHLIB): $(OBJECTS) clean: rm -f $(OBJECTS) $(SHLIB) Makevars.in is also for Unix systems, and it must be accompanied by an empty Makevars.win for Windows systems. Finally, a cleanup script helps to get a tidy package build. Here is an example: #!/bin/sh rm -f src/Makevars configure.log The advantage of this approach is that it will create a src/Makevars file with the correct flags for the system. This way, the package will be portable and easier to test with GitHub Actions or Docker. Testing with Docker CRAN checks packages on different Unix platforms, and additional tests for compiled code include testing for memory leaks with valgrind and address sanitizer. Derived from the recommendations made by Dr. Krylov and Dr. Eddelbuettel in the R-pkg-devel mailing list, you can create the following script to test the package in a Docker container: `bash #!/bin/sh PACKAGE_DIR=$(pwd) DOCKER_IMAGE=\"ghcr.io/r-hub/containers/valgrind:latest\" DOCKER_IMAGE=\"ghcr.io/r-hub/containers/clang-asan:latest\" docker pull $DOCKER_IMAGE docker run --rm -v \"$PACKAGE_DIR\":/workspace -w /workspace $DOCKER_IMAGE bash -c \" Rscript -e 'install.packages(\\\"cpp4r\\\", repos=\\\"https://cran.rstudio.com/\\\")' R CMD build . R CMD check --as-cran --no-manual gccsanissue_0.1.0.tar.gz \" You can add the following function to cpp4rexamples: [[cpp4r::register]] int bad_() { int x = 42; // valid integer int ptr = &x; // pointer to x // undefined behavior (alignment issue) auto misaligned_ptr = reinterpret_cast<long>(ptr); return misaligned_ptr; // Read through misaligned pointer } To access the function from the R session, you can add the following R code: #' @title Bad function #' @description This function has a GCC SAN issue #' @export #' @examples #' bad() bad <- function() { bad_() } The function bad_ introduces undefined behavior by reading through a misaligned pointer. This is a common issue in C++ code, and it is a good example to test the address sanitizer. reinterpret_cast<long> creates a misaligned pointer since ptr is aligned for int, not long. The pointer dereference *misaligned_ptr introduces an undefined behavior. Without sanitizers, this will silently execute, and it returns the value of x. With sanitizers, it will throw an error. When testing with the valgrind container and the command bash dev/test-docker.sh, the R checks will pass, but the valgrind check will fail with the following error: ``bash Shadow bytes around the buggy address: 0x6ffdc4008d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb ==1244==ABORTING References",
    "type": "vignette"
  },
  {
    "title": "12 - External Pointers",
    "url": "vignettes/12-external-pointers.html",
    "content": "In cpp4r, you can use external_pointer. In Rcpp, you can use XPtr to create external pointers. These have significantly different syntax, and cpp4r does not provide an attr method for external pointers. For example, the cpp11tesseract package defines: ``cpp typedef cpp4r::external_pointer<tesseract::TessBaseAPI, tess_finalizer> TessPtr; You can then call TessPtr with: `cpp TessPtr ptr(api); return ptr; As a result, the R equivalent that the OCR C++ function verifies that the engine is such that the following is true: `r stopifnot(inherits(engine, \"externalptr\")) The equivalent tesseract package, which uses Rcpp, defines: typedef Rcpp::XPtr<tesseract::TessBaseAPI, Rcpp::PreserveStorage, tess_finalizer, true> TessPtr; You can then call TessPtr with: `cpp TessPtr ptr(api); ptr.attr(\"class\") = Rcpp::CharacterVector::create(\"tesseract\"); return ptr; Similarly, the Rcpp version checks the engine with: ``r stopifnot(inherits(engine, \"tesseract\")) References",
    "type": "vignette"
  },
  {
    "title": "13 - Compiler Optimizations",
    "url": "vignettes/13-compiler-optimization.html",
    "content": "Motivation R uses default GCC/Clang compiler optimizations, which can limit the performance of C++ code. User-wide Makevars You can use the following Makevars example, which should be placed in ~/.R/Makevars, to set the optimization level to -O3 for all C++ code compiled by R and use additional flags to enable more aggressive optimizations that can be set at setup level but not package level (or CRAN will reject the package): ``bash Override R's optimization level CXXFLAGS = -g -O3 -march=native CXX11FLAGS = -g -O3 -march=native CXX14FLAGS = -g -O3 -march=native CXX17FLAGS = -g -O3 -march=native Additional optimizations CXXFLAGS += -funroll-loops -ftree-vectorize -fprefetch-loop-arrays CXXFLAGS += -fomit-frame-pointer -fstrict-aliasing Link-time optimization CXXFLAGS += -flto=auto LDFLAGS += -flto=auto Anticonf scripts The idea of an \"anticonf\" configure script is to provide a tailored Makevars file with the understanding that a package will be run on different systems. The anticonf name comes from the fact that it is not a standard configure script created with tools such as GNU Autoconf, but rather a templated script that generates a Makevars by detecting the system and compiler settings (e.g., number of cores, optimization flags, etc.). The capybara package has the following Makevars.in file: `make CXX_STD ?= CXX11 CXX14 CXX17 PKG_CXXFLAGS = -DARMA_NO_DEBUG -DARMA_USE_BLAS -DARMA_USE_LAPACK -DCAPYBARA_NCORES=@ncores@ $(SHLIB_OPENMP_CXXFLAGS) @SAFE_OPTFLAGS@ PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS) $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS) This file serves as a template for the Makevars file. The configure script, which runs when the package is installed, replaces the @ncores@ and @SAFE_OPTFLAGS@ placeholders. The Capybara package uses the following configure script: `bash Anticonf script by Pacha (2025) PKG_CONFIG_NAME=\"capybara\" Get R configuration CXX=$(${R_HOME}/bin/R CMD config CXX) CXXFLAGS=$(${R_HOME}/bin/R CMD config CXXFLAGS) Function to test compiler flag test_flag() { echo 'int main(){return 0;}' > conftest.cpp if $CXX $CXXFLAGS $1 conftest.cpp -o conftest >/dev/null 2>&1; then rm -f conftest conftest.cpp return 0 else rm -f conftest conftest.cpp return 1 fi } For CRAN, we cannot override -O2, but we can add other safe optimizations SAFE_OPTFLAGS=\"\" Test portable optimization flags that do not change the -O level PORTABLE_OPTS=\"-funroll-loops -ftree-vectorize\" for opt in $PORTABLE_OPTS; do if test_flag \"$opt\"; then SAFE_OPTFLAGS=\"$SAFE_OPTFLAGS $opt\" fi done if [ -n \"$SAFE_OPTFLAGS\" ]; then echo \"Additional optimizations:$SAFE_OPTFLAGS\" fi Detect number of cores if [ -n \"$CAPYBARA_NCORES\" ]; then num_cores=\"$CAPYBARA_NCORES\" else if [ -f /proc/cpuinfo ]; then num_cores=$(grep -c \"^processor\" /proc/cpuinfo 2>/dev/null || echo 1) elif [ \"$(uname)\" = \"Darwin\" ]; then num_cores=$(sysctl -n hw.ncpu 2>/dev/null || echo 1) else num_cores=1 fi if [ \"$num_cores\" -gt 2 ]; then num_cores=$((num_cores - 1)) fi fi echo \"Default thread count: $num_cores\" Create Makevars from template echo \"Creating src/Makevars\" sed -e \"s|@ncores@|${num_cores}|g\" \\ -e \"s|@SAFE_OPTFLAGS@|${SAFE_OPTFLAGS}|g\" \\ src/Makevars.in > src/Makevars echo \"Configuration complete\" echo \"\" echo \"NOTE: This build will use the default -O2 optimization level for CRAN compliance.\" echo \"For maximum performance, see inst/Makevars.user.example\" exit 0 This script detects the number of cores available on the system and sets the CAPYBARA_NCORES variable accordingly. It also tests for safe optimization flags that can be added to the Makevars file without changing the default -O2` optimization level used by R. It also serves the goal of testing that a simple file can be compiled. References",
    "type": "vignette"
  },
  {
    "title": "14 - Linear Algebra",
    "url": "vignettes/14-linear-algebra.html",
    "content": "Motivation R provides out-of-box support for matrices and vectors. This is not the case for C++ code, where you need to use a library such as Armadillo that has a wrapper for R [@vargassepulveda25]. One of the nicest Armadillo features is that it has a similar syntax to MATLAB. Using Armadillo cpp11armadillo provides a detailed R-specific documentation with worked examples. Because the examples in the cpp11armadillo are self-contained and with detailed explanations, this vignette will not repeat them here. Here is one of the over five-hundred examples from the cpp11armadillo package to compute $\\hat{\\beta} = (X^TX)^{-1}X^Ty$ for a linear model using the cpp4r concepts already covered: ``cpp Mat<double> ols_(const doubles_matrix<>& y, const doubles_matrix<>& x) { Mat<double> Y = as_Mat(y); // Col<double> Y = as_Col(y); also works Mat<double> X = as_Mat(x); Mat<double> XtX = X.t() X; // X'X Mat<double> XtX_inv = inv(XtX); // (X'X)^(-1) Mat<double> beta = XtX_inv X.t() * Y; // (X'X)^(-1)(X'Y) return beta; } [[cpp4r::register]] doubles_matrix<> ols_mat_(const doubles_matrix<>& y, const doubles_matrix<>& x) { Mat<double> beta = ols_(y, x); return as_doubles_matrix(beta); } [[cpp4r::register]] doubles ols_dbl_(const doubles_matrix<>& y, const doubles_matrix<>& x) { Mat<double> beta = ols_(y, x); return as_doubles(beta); } One of the advantages of cpp11armadillo is that it connects cpp11 (and cpp4r) with Armadillo, allowing you to use the as_Mat() and as_doubles_matrix()` functions as the \"bread\" of the sandwich, where pure Armadillo code serves as the \"meat\". References",
    "type": "vignette"
  },
  {
    "title": "15 - Internals",
    "url": "vignettes/15-internals.html",
    "content": "knitr::opts_chunk$set( collapse = TRUE, comment = \"#>\" ) Initial setup and dev workflow The development repository for cpp4r is <https://github.com/pachadotdev/cpp4r>. First install any dependencies needed for development. `` r install.packages(\"remotes\") remotes::install_deps(dependencies = TRUE) You can load the package in an interactive R session ` r devtools::load_all() Or run the cpp4r tests with ` r devtools::test() There are more extensive tests in the cpp4rtest directory. Generally when developing the C++ headers, you can run R with your working directory in the cpp4rtest directory and use devtools::test() to run the cpp4rtests. If you change the cpp4r headers, you will need to install the new version of cpp4r and then clean and recompile the cpp4rtest package: ` r Assuming that your working directory is cpp4rtest/ devtools::clean_dll() devtools::load_all() To calculate code coverage of the cpp4r package run the following from the cpp4r root directory. ` r covr::report(cpp4r_coverage()) Code formatting This project uses clang-format (version 18) to automatically format the C++ code. You can run make format to re-format all code in the project. If your system does not have clang-format version 18, you can install it from https://github.com/pachadotdev/clang-format. Alternatively many IDEs support automatically running clang-format every time files are written. Code organization cpp4r is a header only library, so all source code exposed to users lives in inst/include. R code used to register functions and for cpp4r::cpp_source() is in R/. Tests for only the code in R/ is in tests/testthat/. The rest of the code is in a separate cpp4rtest/ package included in the source tree. Inside cpp4rtest/src the files that start with test- are C++ tests using the Catch support in testthat. In addition there are some regular R tests in cpp4rtest/tests/testthat/. Naming conventions - All header files are named with a .hpp extension. - All source files are named with a .cpp extension. - Public header files should be put in inst/include/cpp4r - Read only r_vector classes and free functions should be put in the cpp4r namespace. - Writable r_vector class should be put in the cpp4r::writable namespace. - Private classes and functions should be put in the cpp4r::internal namespace. Vector classes All of the basic r_vector classes are class templates, the base template is defined in cpp4r/r_vector.hpp. The template parameter is the type of value the particular R vector stores, e.g. double for cpp4r::doubles. This differs from Rcpp, whose first template parameter is the R vector type, e.g. REALSXP. The file first has the class declarations, then function definitions further down in the file. Specializations for the various types are in separate files, e.g. cpp4r/doubles.hpp, cpp4r/integers.hpp Coercion functions There are two different coercion functions as_sexp() takes a C++ object and coerces it to a SEXP object, so it can be used in R. as_cpp<>() is a template function that takes a SEXP and creates a C++ object from it The various methods for both functions are defined in cpp4r/as.hpp This is definitely the most complex part of the cpp4r code, with extensive use of template metaprogramming. In particular the substitution failure is not an error (SFINAE) technique is used to control overloading of the functions. If you could use C++20, a lot of this code would be made simpler with Concepts, but alas. The most common C++ types are included in the test suite and should work without issues, as more exotic types are used in real projects additional issues may arise. Some useful links on SFINAE - https://www.fluentcpp.com/2018/05/15/make-sfinae-pretty-1-what-value-sfinae-brings-to-code/, https://www.fluentcpp.com/2018/05/18/make-sfinae-pretty-2-hidden-beauty-sfinae/ Protection Protect list cpp4r uses an idea proposed by Luke Tierney to use a double linked list with the head preserved to protect objects cpp4r is protecting. Each node in the list uses the head (CAR) part to point to the previous node, and the CDR part to point to the next node. The TAG is used to point to the object being protected. The head and tail of the list have R_NilValue as their CAR and CDR pointers respectively. Calling cpp4r::detail::store::insert() with a regular R object will add a new node to the list and return a protect token corresponding to the node added. Calling cpp4r::detail::store::release() on this returned token will release the protection by unlinking the node from the linked list. These two functions are considered internal to cpp4r, so do not use them in your packages. This scheme scales in O(1) time to release or insert an object vs O(N) or worse time with R_PreserveObject() / R_ReleaseObject(). Each package has its own unique protection list, which avoids the need to manage a \"global\" protection list shared across packages. A previous version of cpp4r used a global protection list stored in an R global option, but this caused multiple issues. These functions are defined in protect.hpp. Unwind Protect cpp4r uses R_UnwindProtect() to protect (most) calls to the R API that could fail. These are usually those that allocate memory, though in truth most R API functions could error along some paths. If an error happens under R_UnwindProtect(), cpp4r will throw a C++ exception. This exception is caught by the try/catch block defined in the BEGIN_CPP4R macro in cpp4r/declarations.hpp. The exception will cause any C++ destructors to run, freeing any resources held by C++ objects. After the try/catch block exits, the R error unwinding is then continued by R_ContinueUnwind() and a normal R error results. R \\>=3.5 is required to use cpp4r, but when it was created, the goal was to support back to R 3.3, but R_ContinueUnwind() was not available until R 3.5. Below are a few other options that were considered to support older R versions: 1. Using R_TopLevelExec() works to avoid the C long jump, but because the code is always run in a top level context any errors or messages thrown cannot be caught by tryCatch() or similar techniques. 2. Using R_TryCatch() is not available prior to R 3.4, and also has a serious bug in R 3.4 (fixed in R 3.5). 3. Calling the R level tryCatch() function which contains an expression that runs a C function which then runs the C++ code would be an option, but implementing this is convoluted and it would impact performance, perhaps severely. 4. Have cpp4r::unwind_protect() be a no-op for these versions. This means any resources held by C++ objects would leak, including cpp4r::r_vector / cpp4r::sexp` objects. None of these options were perfect. Here are some pros and cons for each: 1. Causes behavior changes and test failures, so it was ruled out. 2. Was also ruled out since we wanted to support back to R 3.3. 3. Was ruled out partially because the implementation would be somewhat tricky and more because performance would suffer greatly. 4. Is what was ended up being done before requiring R 3.5. It leaked protected objects when there were R API errors.",
    "type": "vignette"
  },
  {
    "title": "17 - FAQs",
    "url": "vignettes/16-FAQ.html",
    "content": "``r knitr::opts_chunk$set( collapse = TRUE, comment = \"#>\" ) library(cpp4r) Below are some Frequently Asked Questions about cpp4r. If you have a question that you think would fit well here please open an issue. 1. What are the underlying types of cpp4r objects? | vector | element | |-----------------|-----------------| | cpp4r::integers | int | | cpp4r::doubles | double | | cpp4r::logicals | cpp4r::r_bool | | cpp4r::strings | cpp4r::r_string | | cpp4r::raws | uint8_t | | cpp4r::list | SEXP | 2. How do I add elements to a list? Use the push_back() method. You will need to use cpp4r::as_sexp() if you want to convert arbitrary C++ objects to SEXP before inserting them into the list. `cpp #include <cpp4r.hpp> #include <vector> [[cpp4r::register]] cpp4r::writable::list foo_push() { cpp4r::writable::list x; // An object that is already a SEXP x.push_back(R_NilValue); // A single integer x.push_back(cpp4r::as_sexp(1)); // A C++ vector of ints std::vector<int> elt{1, 2, 3}; x.push_back(cpp4r::as_sexp(elt)); return x; } To create named lists, use the push_back() method with the named literal syntax. The named literal syntax is defined in the cpp4r::literals namespace. In this case, creating the named literal automatically calls as_sexp() for you. `cpp #include <cpp4r.hpp> [[cpp4r::register]] cpp4r::writable::list foo_push_named() { using namespace cpp4r::literals; cpp4r::writable::list x; x.push_back({\"foo\"_nm = 1}); return x; } Note that if you know the size of the list ahead of time (which you often do!), then it is more efficient to state that up front. `cpp #include <cpp4r.hpp> #include <vector> [[cpp4r::register]] cpp4r::writable::list foo_push_sized() { std::vector<int> elt{1, 2, 3}; R_xlen_t size = 3; cpp4r::writable::list x(size); x[0] = R_NilValue; x[1] = cpp4r::as_sexp(1); x[2] = cpp4r::as_sexp(elt); return x; } 3. Does cpp4r support default arguments? cpp4r does not support default arguments, while convenient they would require more complexity to support than is currently worthwhile. If you need default argument support you can use a wrapper function around your cpp4r registered function. A common convention is to name the internal function with a trailing _. `cpp #include <cpp4r.hpp> [[cpp4r::register]] double add_some_(double x, double amount) { return x + amount; } `r add_some <- function(x, amount = 1) { add_some_(x, amount) } add_some(1) add_some(1, amount = 5) 4. How do I create a new empty list? Define a new writable list object. cpp4r::writable::list x; 5. How do I retrieve (named) elements from a named vector/list? Use the [] accessor function. x[\"foo\"] 6. How can I tell whether a vector is named? Use the named() method for vector classes. `cpp #include <cpp4r.hpp> [[cpp4r::register]] bool is_named(cpp4r::strings x) { return x.named(); } `r is_named(\"foo\") is_named(c(x = \"foo\")) 7. How do I return a cpp4r::writable::logicals object with only a FALSE value? You need to use list initialization with {} to create the object. `cpp #include <cpp4r.hpp> [[cpp4r::register]] cpp4r::writable::logicals my_false() { return {FALSE}; } [[cpp4r::register]] cpp4r::writable::logicals my_true() { return {TRUE}; } [[cpp4r::register]] cpp4r::writable::logicals my_both() { return {TRUE, FALSE, TRUE}; } `r my_false() my_true() my_both() 8. How do I create a new empty environment? To do this you need to call the base::new.env() function from C++. This can be done by creating a cpp4r::function object and then calling it to generate the new environment. `cpp #include <cpp4r.hpp> [[cpp4r::register]] cpp4r::environment create_environment() { cpp4r::function new_env(cpp4r::package(\"base\")[\"new.env\"]); return new_env(); } 9. How do I assign and retrieve values in an environment? What happens if I try to get a value that does not exist? Use [] to retrieve or assign values from an environment by name. If a value does not exist, it will error. To check for existence ahead of time, use the exists() method. `cpp #include <cpp4r.hpp> [[cpp4r::register]] bool foo_exists(cpp4r::environment x) { return x.exists(\"foo\"); } [[cpp4r::register]] void set_foo(cpp4r::environment x, double value) { x[\"foo\"] = value; } `r x <- new.env() foo_exists(x) set_foo(x, 1) foo_exists(x) 10. How can I create a cpp4r:raws from a std::string? There is no built in way to do this. One method would be to push_back() each element of the string individually. `cpp #include <cpp4r.hpp> [[cpp4r::register]] cpp4r::raws push_raws() { std::string x(\"hi\"); cpp4r::writable::raws out; for (auto c : x) { out.push_back(c); } return out; } `r push_raws() 11. How can I create a std::string from a cpp4r::writable::string? Because C++ does not allow for two implicit cast, explicitly cast to cpp4r::r_string first. `cpp #include <cpp4r.hpp> #include <string> [[cpp4r::register]] std::string my_string() { cpp4r::writable::strings x({\"foo\", \"bar\"}); std::string elt = cpp4r::r_string(x[0]); return elt; } 12. What are the types for C++ iterators? The iterators are ::iterator classes contained inside the vector classes. For example the iterator for cpp4r::doubles would be cpp4r::doubles::iterator and the iterator for cpp4r::writable::doubles would be cpp4r::writable::doubles::iterator. 13. My code has using namespace std, why do I still have to include std:: in the signatures of [[cpp4r::register]] functions? The using namespace std directive will not be included in the generated code of the function signatures, so they still need to be fully qualified. However you will not need to qualify the type names within those functions. The following will not compile `cpp #include <cpp4r.hpp> #include <string> using namespace std; [[cpp4r::register]] string foobar() { return string(\"foo\") + \"-bar\"; } But this will compile and work as intended `cpp #include <cpp4r.hpp> #include <string> using namespace std; [[cpp4r::register]] std::string foobar() { return string(\"foo\") + \"-bar\"; } 14. How do I modify a vector in place? In place modification breaks the normal semantics of R code. In general it should be avoided, which is why cpp4r::writable classes always copy their data when constructed. However, if you are positive in-place modification is necessary for your use case, you can use the move constructor to do this. `cpp #include <cpp4r.hpp> [[cpp4r::register]] void add_one(cpp4r::sexp x_sexp) { cpp4r::writable::integers x(std::move(x_sexp.data())); for (auto&& value : x) { ++value; } } `r x <- c(1L, 2L, 3L, 4L) .Internal(inspect(x)) add_one(x) .Internal(inspect(x)) x 15. Should I call cpp4r::unwind_protect() manually? cpp4r::unwind_protect() is cpp4r's way of safely calling R's C API. In short, it allows you to run a function that might throw an R error, catch the longjmp() of that error, promote it to an exception that is thrown and caught by a try/catch that cpp4r sets up for you at .Call() time (which allows destructors to run), and finally tells R to continue unwinding the stack now that the C++ objects have had a chance to destruct as needed. Since cpp4r::unwind_protect() takes an arbitrary function, you may be wondering if you should use it for your own custom needs. In general, this is advised against because this is an extremely advanced feature that is prone to subtle and hard to debug issues. Destructors The following setup for test_destructor_ok() with a manual call to unwind_protect() would work: `cpp #include <cpp4r.hpp> class A { public: ~A(); }; A::~A() { Rprintf(\"hi from the destructor!\"); } [[cpp4r::register]] void test_destructor_ok() { A a{}; cpp4r::unwind_protect([&] { Rf_error(\"oh no!\"); }); } [[cpp4r::register]] void test_destructor_bad() { cpp4r::unwind_protect([&] { A a{}; Rf_error(\"oh no!\"); }); } `r test_destructor_ok() But if you happen to move a into the unwind_protect(), then it will not be destructed, and you will end up with a memory leak at best, and a much more sinister issue if your destructor is important: `r test_destructor_bad() #> Error: oh no! In general, the only code that can be called within unwind_protect() is \"pure\" C code or C++ code that only uses POD (plain-old-data) types and no exceptions. If you mix complex C++ objects with R's C API within unwind_protect(), then any R errors will result in a jump that prevents your destructors from running. Nested unwind_protect() Another issue that can arise has to do with nested calls to unwind_protect(). It is very hard (if not impossible) to end up with invalidly nested unwind_protect() calls when using the typical cpp4r API, but you can manually create a scenario like the following: `cpp #include <cpp4r.hpp> [[cpp4r::register]] void test_nested() { cpp4r::unwind_protect([&] { cpp4r::unwind_protect([&] { Rf_error(\"oh no!\"); }); }); } If you were to run test_nested() from R, it would likely crash or hang your R session due to the following chain of events: - test_nested() sets up a try/catch to catch unwind exceptions - The outer unwind_protect() is called. It uses the C function R_UnwindProtect() to call its lambda function. - The inner unwind_protect() is called. It again uses R_UnwindProtect(), this time to call Rf_error(). - Rf_error() performs a longjmp() which is caught by the inner unwind_protect() and promoted to an exception. - That exception is thrown, but because the code is in the outer call to R_UnwindProtect() (a C function), it ends up throwing that exception across C stack frames. This is undefined behavior, which is known to have caused R to crash on certain platforms. You might think that you'd never do this, but the same scenario can also occur with a combination of 1 call to unwind_protect() combined with usage of the cpp4r API: `cpp #include <cpp4r.hpp> [[cpp4r::register]] void test_hidden_nested() { cpp4r::unwind_protect([&] { cpp4r::stop(\"oh no!\"); }); } Because cpp4r::stop() (and most of the cpp4r API) uses unwind_protect() internally, this has indirectly ended up in a nested unwind_protect() scenario again. In general, if you must use unwind_protect() then you must be very careful not to use any of the cpp4r API inside of the unwind_protect() call. It is worth pointing out that calling out to an R function from cpp4r which then calls back into cpp4r is still safe, i.e. if the registered version of the imaginary test_outer() function below was called from R, then that would work: `cpp #include <cpp4r.hpp> [[cpp4r::register]] void test_inner() { cpp4r::stop(\"oh no!\") } [[cpp4r::register]] void test_outer() { auto fn = cpp4r::package(\"mypackage\")[\"test_inner\"] fn(); } This might seem unsafe because cpp4r::package() uses unwind_protect() to call the R function for test_inner(), which then goes back into C++ to call cpp4r::stop(), which itself uses unwind_protect(), so it seems like the code is in a nested scenario, but this scenario does actually work. It makes more sense if you analyze it one step at a time: - Call the R function for test_outer() - A try/catch is set up to catch unwind exceptions - The C++ function for test_outer() is called - cpp4r::package() uses unwind_protect() to call the R function for test_inner() - Call the R function for test_inner() - A try/catch is set up to catch unwind exceptions (this is the key!) - The C++ function for test_inner() is called - cpp4r::stop(\"oh no!\") is called, which uses unwind_protect() to call Rf_error(), causing a longjmp(), which is caught by that unwind_protect() and promoted to an exception. - That exception is thrown, but this time it is caught by the try/catch set up by test_inner() as it was entered from the R side. This prevents that exception from crossing the C++ -\\> C boundary. - The try/catch calls R_ContinueUnwind(), which longjmp()s again, and now the unwind_protect() set up by cpp4r::package() catches that, and promotes it to an exception. - That exception is thrown and caught by the try/catch set up by test_outer(). - The try/catch calls R_ContinueUnwind(), which longjmp()s again, and at this point the longjmp() can safely proceed to force an R error. 16. Ok but I really want to call cpp4r::unwind_protect() manually If you have read the above bullet and still feel like you need to call unwind_protect(), then you should keep in mind the following when writing the function to unwind-protect: - You should not create any C++ objects that have destructors. - You should not use any parts of the cpp4r API that may call unwind_protect(). - You must be very careful not to call unwind_protect() in a nested manner. In other words, if you only use plain-old-data types, are careful to never throw exceptions, and only use R's C API, then you can use unwind_protect(). One place you may want to do this is when working with long character vectors. Unfortunately, due to the way cpp4r must protect the individual CHARSXP objects that make up a character vector, it can currently be quite slow to use the cpp4r API for this. Consider this example of extracting out individual elements with x[i] vs using the native R API: `cpp #include <cpp4r.hpp> [[cpp4r::register]] cpp4r::sexp test_extract_cpp4r(cpp4r::strings x) { const R_xlen_t size = x.size(); for (R_xlen_t i = 0; i < size; ++i) { (void) x[i]; } return R_NilValue; } [[cpp4r::register]] cpp4r::sexp test_extract_r_api(cpp4r::strings x) { const R_xlen_t size = x.size(); const SEXP data{x}; cpp4r::unwind_protect([&] { for (R_xlen_t i = 0; i < size; ++i) { (void) STRING_ELT(data, i); } }); return R_NilValue; } `r set.seed(123) x <- sample(letters, 1e6, replace = TRUE) bench::mark( test_extract_cpp4r(x), test_extract_r_api(x) ) There are plans to improve on this in the future, but for now this is one of the only places where it is felt to be reasonable to call unwind_protect() manually. 17. How do I modify a matrix rownames/colnames on C++ side? Any of the following options will work (the commented code works with cpp4r): ``cpp [[cpp4r::register]] cpp4r::doubles_matrix<> copy_mat(cpp4r::doubles_matrix<> x) { cpp4r::writable::doubles_matrix<> out = x; // SEXP dimnames = x.attr(\"dimnames\"); // if (dimnames != R_NilValue) { // Rf_setAttrib(out.data(), R_DimNamesSymbol, dimnames); // } out.attr(\"dimnames\") = x.attr(\"dimnames\"); return out; } [[cpp4r::register]] SEXP copy_mat_as_sexp(cpp4r::doubles_matrix<> x) { cpp4r::writable::doubles_matrix<> out = x; // SEXP dimnames = x.attr(\"dimnames\"); // if (dimnames != R_NilValue) { // Rf_setAttrib(out.data(), R_DimNamesSymbol, dimnames); // } out.attr(\"dimnames\") = x.attr(\"dimnames\"); return out; } [[cpp4r::register]] cpp4r::doubles_matrix<> create_mat() { cpp4r::writable::doubles_matrix<> out(2, 2); out(0, 0) = 1; out(0, 1) = 2; out(1, 0) = 3; out(1, 1) = 4; cpp4r::writable::list dimnames(2); dimnames[0] = cpp4r::strings({\"a\", \"b\"}); dimnames[1] = cpp4r::strings({\"c\", \"d\"}); out.attr(\"dimnames\") = dimnames; return out; } [[cpp4r::register]] cpp4r::doubles_matrix<> create_mat_no_rownames() { cpp4r::writable::doubles_matrix<> out(2, 2); out(0, 0) = 1; out(0, 1) = 2; out(1, 0) = 3; out(1, 1) = 4; cpp4r::writable::list dimnames(2); dimnames[0] = R_NilValue; // No row names dimnames[1] = cpp4r::strings({\"x1\", \"x2\"}); out.attr(\"dimnames\") = dimnames; return out; }",
    "type": "vignette"
  },
  {
    "title": "16 - Worked Examples",
    "url": "vignettes/17-worked-examples.html",
    "content": "Motivation The previous package skeleton left out some essential details, such as testing for memory leaks and debugging. This vignette will cover these aspects in more detail. The references for this vignette are @vaughan24, @padgham22, @vaughan19, and @wickham19. Instructional examples Solving a matrix using the Gauss-Jordan method This example package covers the following topics: Integers Doubles Matrices Conditionals Loops (for) Vendoring See the cpp4rgaussjordan package. Details This implementation is a naive approach, but it can be used, for example, to obtain the Ordinary Least Squares (OLS) estimator as shown in the next section. Vendoring means that the dependency code, the cpp4r C++ headers, are copied the project's source tree. This ensures the dependency code is fixed and stable until it is updated. The advantage of vendoring is that changes to the cpp4r package could never break the package's code. The disadvantage is that fixes and new features will be available after vendoring the code again. Vendoring You can start with create_package(\"~/github/cpp4rgaussjordan\"). You can use VSCode, but all the steps also apply to RStudio. After opening ~/github/cpp4rgaussjordan, you can run use_cpp4r() to have a readily available skeleton in your project. You can run use_apache_licence() to have a LICENSE file and indicate in DESCRIPTION that your package is distributed under the Apache License. Then you can run cpp_vendor() to copy the C++ headers into inst/include. Building and testing You can use devtools to build and test the package: ``r build devtools::clean_dll() cpp4r::cpp_register() devtools::document() devtools::load_all() test A <- matrix(c(2,1,3,-1), nrow = 2, ncol = 2) invert_matrix(A) > invert_matrix(A) [,1] [,2] [1,] 0.2 0.6 [2,] 0.2 -0.4 Ordinary Least Squares (OLS) estimator This example package covers the following topics: Integers Doubles Doubles matrices Conditionals See the cpp4rols package. This implementation is extremely naive, quite similar to the Gauss-Jordan example with extra steps, and it is enough to show how to use C++ code within R. One approach is to create one function per step, which means creating one function to obtain $X^tX$, another for $(X^tX)^{-1}$ (e.g, implementing the Gauss-Jordan method to invert a matrix), another for $X^tY$ and then calling each of those functions to obtain $\\hat{\\beta} = (X^tX)^{-1}(X^tY)$. A good challenge would be to implement the QR decomposition used by the lm() function in R and use it to obtain the OLS estimator in C++. @drury16 provides a good starting point, this is not trivial to implement. It is hard to beat the performance of the lm() function in R, which calls compiled C and FORTRAN functions, and these functions are fast and robust lm(). Linear programming (Simplex phase 2) This example package covers the following topics: Integers Doubles Doubles matrices Conditionals Loops (for and while) Messages See the cpp4rsimplex package. Algorithm The simplex algorithm is well described in Introduction to Linear Optimization and there is efficient software to solve this, including @lpsolve23. A problem written in canonical form is represented by a table such as: $$ \\begin{array}{ccc|c} x_1 & \\cdots & x_n & \\\\ \\hline c_1 & \\cdots & c_n & -z \\\\ a_{11} & \\cdots & a_{1n} & b_1 \\\\ \\vdots & \\ddots & \\vdots & \\vdots \\\\ a_{m1} & \\cdots & a_{mn} & b_m \\end{array} $$ where $c_1, \\ldots, c_n$ are the coefficients of the objective function (i.e., costs), $a_{11}, \\ldots, a_{mn}$ are the coefficients of the constraints, and $b_1, \\ldots, b_m$ are the right-hand side of the constraints. The simplex algorithm to solve the problem consists in the next steps: 1. If $c_j \\geq 0$ for all $j$, then the current solution is optimal. Basic variables are equal to $b_i$ and non-basic variables are equal to 0. 2. If $c_j < 0$ for some $j$, choose it to enter the base. Choose the variable with the most negative $c_j$, and assume that it is $j = s$. 3. If $a_{is} \\leq 0$ for all $i$, then the problem is unbounded. 4. If $a_{is} > 0$ for some $i$, choose $i = r$ such that $b_r / a_{rs} = \\min(b_i / a_{is},\\: a_{is} > 0)$ and pivot on $a_{rs}$, to then go back to step 1. The coefficients are updated according to: 1. $a_{ij} \\leftarrow a_{ij} - (a_{is} a_{rj}) / a_{rs}$ for $j \\neq s$ 2. $a_{rj} \\leftarrow a_{rj} / a_{rs}$ 3. $b_i \\leftarrow b_i - (a_{is} b_r) / a_{rs}$ for $i \\neq r$ 4. $b_r \\leftarrow b_r / a_{rs}$ 5. $c_j \\leftarrow c_j - (c_s a_{rj}) / a_{rs}$ 6. $-z \\leftarrow -z - (c_s b_r) / a_{rs}$ This algorithm is equivalent to Gauss method to solve linear systems. Numerical example A simple example is the following minimization problem: $$ \\begin{aligned} \\text{min} \\quad & -x_1 - 3x_2 \\\\ \\text{subject to} \\quad & x_1 + x_2 \\geq 3 \\\\ & -3x_1 + x_2 \\geq 2 \\\\ & x_1, x_2 \\geq 0 \\end{aligned} $$ In canonical form, this problem is: $$ \\begin{aligned} \\text{min} \\quad & -x_1 - 3x_2 + 0x_3 + 0x_4 \\\\ \\text{subject to} \\quad & x_1 + x_2 + x_3 = 3 \\\\ & -3x_1 + x_2 + x_4 = 2 \\\\ & x_1, x_2,x_3,x_4 \\geq 0 \\end{aligned} $$ The initial tableau for the problem is: $$ \\begin{array}{cccc|c} x_1 & x_2 & x_3 & x_4 & -z \\\\ \\hline -1 & -3 & 0 & 0 & 0 \\\\ 1 & 1 & 1 & 0 & 3 \\\\ -3 & 1 & 0 & 1 & 2 \\end{array} $$ The first row is the cost row, the last column is the right-hand side, and the rest is the matrix $A$. The first step is to pivot on row 2 and column 2: $$ \\begin{array}{cccc|c} x_1 & x_2 & x_3 & x_4 & -z \\\\ \\hline -10 & 0 & 0 & 3 & 6 \\\\ 4 & 0 & 1 & -1 & 1 \\\\ -3 & 1 & 0 & 1 & 2 \\end{array} $$ The second step is to pivot on row 2 and column 1: $$ \\begin{array}{cccc|c} x_1 & x_2 & x_3 & x_4 & -z \\\\ \\hline 0 & 0 & 5/2 & 1/2 & 17/2 \\\\ 1 & 0 & 1/4 & -1/4 & 1/4 \\\\ 0 & 1 & 3/4 & 1/4 & 11/4 \\end{array} $$ Here a stopping criterion is reached: the minimum cost is non-negative, therefore the solution is optimal and is $x^ = (1/4, 11/4, 0 , 0)$ with an optimal value $z^ = -17/2$. Building and testing You can use devtools to build and test the package: `r build devtools::clean_dll() cpp4r::cpp_register() devtools::document() devtools::load_all() test c <- c(-1, -3) b <- c(3, 2) A <- matrix( c(1, -3, 1, 1), nrow = 2, ncol = 2, byrow = FALSE ) cpp4r_simplex_phase2(c, b, A) The result should be: `r Initial tableau: -1 -3 0 0 0 1 1 1 0 3 -3 1 0 1 2 Minimum cost: -3 Pivot row: 2 Pivot column: 2 ==== New tableau: -10 0 0 3 6 4 0 1 -1 1 -3 1 0 1 2 Minimum cost: -10 Pivot row: 1 Pivot column: 1 ==== New tableau: 0 0 2.5 0.5 8.5 1 0 0.25 -0.25 0.25 0 1 0.75 0.25 2.75 Minimum cost: 0 Optimal solution found in 2 steps ! Using OMP (parallelization) This example package covers the following topics: Integers Doubles Lists (unnamed and named) Loops (for) OpenMP parallelization See the cpp4romp package. Motivation One common phrase that you might find when you need to search how to do something with cpp4r is: \"cpp4r does not offer OpenMP support.\" This is a myth. cpp4r does offer OpenMP support. The requirements are: A processor and C++ compiler that support OpenMP. This has been tested on Windows, where you need to install Rtools, and Ubuntu where you do not need anything special because the gcc compiler comes with the operating system and it just works. If you are using macOS, you need to install libomp via Homebrew in order to extend the clang compiler, and this is explained in the OpenBox documentation [@openbox24]. Enabling OpenMP You can create an R package called cpp4romp with the following code: `r usethis::create_project(\"cpp4romp\") usethis::use_cpp4r() Then, you can create the file R/cpp4romp-package.R with the following contents: `r usethis namespace: start #' @useDynLib cpp4romp, .registration = TRUE usethis namespace: end NULL In order to get the #pragma instruction to work, you need to add the following to src/Makevars: PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) -DARMA_OPENMP_THREADS=1 PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS) CXX_STD = CXX11 Not adding this means that the pragma instruction will be ignored and the functions will run in a single thread. Unnamed list You can add a function called squared_unnamed_ in src/code.cpp that will square each element in a vector of doubles, so the file content corresponds to the following: `cpp #include <cpp4r.hpp> #include <omp.h> using namespace cpp4r; [[cpp4r::register]] list squared_unnamed_(doubles x) { // create vectors y = x^2 and z = thread number int n = x.size(); writable::doubles y(n); writable::doubles z(n); #pragma omp parallel for for (int i = 0; i < n; ++i) { y[i] = x[i] x[i]; z[i] = omp_get_thread_num(); } //create a list containing y and z writable::list out; out.push_back(y); out.push_back(z); return out; } The previous function returns an unnamed list with two elements: the squared vector and the thread number. The function is registered with [[cpp4r::register]] so that it can be called from R. C++ is strict with types, so you need to create a wrapper function that will convert the integers to doubles to avoid accidental errors, it will go in R/cpp4romp-package.R: `r #' Unnamed list with squared numbers and the threads used #' @param x A vector of doubles #' @export squared_unnamed <- function(x) { squared_unnamed_(as.double(x)) } Named list You can add a function called squared_named_ in src/code.cpp that does the same but returns a named list. The additional content corresponds to the following: `cpp [[cpp4r::register]] list squared_named_(doubles x) { // create vectors y = x^2 and z = thread number int n = x.size(); writable::doubles y(n); writable::doubles z(n); #pragma omp parallel for for (int i = 0; i < n; ++i) { y[i] = x[i] x[i]; z[i] = omp_get_thread_num(); } //create a list containing y and z writable::list out; out.push_back({\"x^2\"_nm = y}); out.push_back({\"thread\"_nm = z}); return out; } As in the previous part, you can add a wrapper and documentation: `r #' Named list with squared numbers and the threads used #' @param x A vector of doubles #' @export squared_named <- function(x) { squared_named_(as.double(x)) } Building and testing You can use devtools to build and test the package: `r cpp4r::cpp_register() devtools::document() devtools::install() Then, you can test the package from a new R session: `r > library(cpp4romp) > squared_unnamed(1:10) [[1]] [1] 1 4 9 16 25 36 49 64 81 100 [[2]] [1] 0 0 1 1 2 3 4 5 6 7 > squared_named(1:10) $x^2 [1] 1 4 9 16 25 36 49 64 81 100 $thread [1] 0 0 1 1 2 3 4 5 6 7 Implementing a rejection and bootstrap sampler This example package covers the following topics: Integers Doubles Matrices Push back Random seed state See the differences between cpp11, cpp4r and Rcpp: cpp11sampling package. cpp4rsampling package. Rcppsampling package. Extensive R/C++ tests See the cpp4rtest package. It covers over 1,000 unit tests for cpp4r features, including: Vectors (integers, doubles, logicals, strings) Matrices (integers, doubles, logicals, strings) Lists (named and unnamed) Data frames Error handling (stop, warning, message) C++ side unit tests with testthat Roxygen documentation Useful R/C++ Integration Examples Here are some examples of C++ code integration with R using the cpp11 package: arrow: An R package that provides bindings to the Arrow C++ library. Arrow is a columnar in-memory analytics format that is extremely fast and efficient. cpp4rarmadillo: An R package that provides bindings to the Armadillo C++ library. Armadillo is a high-quality linear algebra library with a syntax similar to MATLAB. cpp11eigen: An R package that provides bindings to the Eigen C++ library. Eigen is a high-performance linear algebra library with a permissive license. haven: A package that reads and writes SPSS, Stata, and SAS files in R. kendallknight: Implements the Kendall's correlation coefficient in C++, achieving speedup by using an algorithm with a complexity of $O(n \\log(n))$ instead of $O(n^2)$ in base R. mice: A package that imputes missing data using multivariate chained equations. redatam: C++ implementation of the Redatam file format, callable from both R and Python. RPostgres: A C++ interface to PostgreSQL using cpp4r`. * tidyr: A package that uses C++ functions to reshape data frames. References",
    "type": "vignette"
  }
]
