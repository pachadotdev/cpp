[{"path":[]},{"path":"./CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement [INSERT CONTACT METHOD]. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"./CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/ code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https:// www.contributor-covenant.org/translations.","code":""},{"path":"./CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to cpp4r","title":"Contributing to cpp4r","text":"outlines propose change cpp4r. detailed info contributing , tidyverse packages, please see development contributing guide.","code":""},{"path":"./CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to cpp4r","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"./CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to cpp4r","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed).","code":""},{"path":"./CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to cpp4r","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"r-lib/cpp4r\", fork = TRUE). Install development dependences devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"./CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to cpp4r","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"./CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to cpp4r","text":"Please note cpp4r project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"./LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"./LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"./LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"./LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"./LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"./LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"./LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"./LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"./LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"./LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"./LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"./SUPPORT.html","id":null,"dir":"","previous_headings":"","what":"Getting help with cpp4r","title":"Getting help with cpp4r","text":"Thanks using cpp4r! filing issue, places explore pieces put together make process smooth possible.","code":""},{"path":"./SUPPORT.html","id":"make-a-reprex","dir":"","previous_headings":"","what":"Make a reprex","title":"Getting help with cpp4r","text":"Start making minimal reproducible example using reprex package. haven’t heard used reprex , ’re treat! Seriously, reprex make R-question-asking endeavors easier (pretty insane ROI five ten minutes ’ll take learn ’s ). additional reprex pointers, check Get help! section tidyverse site.","code":""},{"path":"./SUPPORT.html","id":"where-to-ask","dir":"","previous_headings":"","what":"Where to ask?","title":"Getting help with cpp4r","text":"Armed reprex, next step figure ask. ’s question: start community.rstudio.com, /StackOverflow. people answer questions. ’s bug: ’re right place, file issue. ’re sure: let community help figure ! problem bug feature request, can easily return report . opening new issue, sure search issues pull requests make sure bug hasn’t reported /already fixed development version. default, search pre-populated :issue :open. can edit qualifiers (e.g. :pr, :closed) needed. example, ’d simply remove :open search issues repo, open closed.","code":""},{"path":"./SUPPORT.html","id":"what-happens-next","dir":"","previous_headings":"","what":"What happens next?","title":"Getting help with cpp4r","text":"efficient possible, development tidyverse packages tends bursty, shouldn’t worry don’t get immediate response. Typically don’t look repo sufficient quantity issues accumulates, ’s burst intense activity focus efforts. makes development efficient avoids expensive context switching problems, cost taking longer get back . process makes good reprex particularly important might multiple months initial report start working . can’t reproduce bug, can’t fix !","code":""},{"path":"./articles/01-motivations.html","id":"motivation-and-significance","dir":"Articles","previous_headings":"","what":"Motivation and significance","title":"01 - Motivations for cpp4r","text":"R programming language maintained long-standing tradition interfacing compiled languages, dating back original S implementation late 1970s, served primarily wrapper around FORTRAN routines (Chambers 2006). integration remains relevant today, R code sometimes lacks performance needed computationally intensive tasks. Even optimizing R code vectorization avoiding unnecessary object copying, bottlenecks may persist require compiled language solutions. C++ offers particular advantages addressing common R performance bottlenecks, including: Loops easily vectorized due dependencies iterations Recursive functions problems requiring many function calls Data structures algorithms natively available R (e.g., R let end-user use pointers pass--reference semantics) Problems requiring fine-tuning memory management cpp4r R package provides C++11 bindings R, enabling use C++ code R packages. fork cpp11 package (Vaughan, Hester, François 2025) aiming provide additional features improvements maintaining compatibility original cpp11 API. landscape C++ bindings R evolved significantly past two decades. cxx package, released 2000, provided early prototype C++ bindings (Hornik 2001). Rcpp, first published CRAN 2008, became mainstream solution 2,000 reverse dependencies 2020 (Eddelbuettel Francois 2011). subsequent attempt, Rcpp11, released 2014 achieve widespread adoption (Francois, Ushey, Chambers 2020). Rcpp highly successful, adding modern C++ features addressing certain architectural issues require substantial breaking changes maintain backward compatibility extensive ecosystem dependent packages. address limitations, cpp11 package (Vaughan, Hester, François 2023) released 2023 reimplementation C++ bindings R, incorporating modern C++ features different design trade-offs aiming provide: Enforced copy--write semantics consistent R’s behavior Improved safety interfacing R’s C API Native support ALTREP objects UTF-8 string handling throughout Modern C++11 features idioms Simplified implementation compared Rcpp Faster compilation reduced memory requirements Completely header-design avoid Application Binary Interface (ABI) compatibility issues","code":""},{"path":"./articles/01-motivations.html","id":"software-description","dir":"Articles","previous_headings":"","what":"Software description","title":"01 - Motivations for cpp4r","text":"using cpp11 keep thesis project minimal terms code duplication reusing existing components instead, identified several enhancements benefit R community improve usability library including: Support converting C++ standard containers (maps) R lists Roxygen documentation support directly C++ code Proper handling matrix attributes Support nullable external pointers Immediate availability values added via push_back() Bidirectional copy complex number types Flexibility type conversions Various performance optimizations discussing proposed enhancements cpp11 maintainers, became clear development priorities timelines accommodate features near term. led creation cpp4r, fork cpp11 incorporates additional features maintaining compatibility original cpp11 API. means cpp4r can serve drop-replacement cpp11 case, allowing users benefit enhancements without significant code changes. converse, replacing cpp4r cpp11, requires adjustments due additional features cpp4r. cpp4r extends cpp11’s container support enabling seamless conversion C++ standard library containers R objects. includes support std::map std::unordered_map containers, automatically converted named R lists. cpp4r provides roxygen support directly C++ code, allowing developers document C++ functions using familiar roxygen2 syntax. integration streamlines documentation workflow packages expose C++ functions R. Unlike cpp11, cpp4r properly handles matrix attributes, including dimnames, ensuring matrix operations preserve metadata copying data R C++. cpp4r offers flexible type conversion functions. example, as_integers() as_doubles() accept logical inputs, providing greater flexibility handling diverse input types compared restrictive cpp11 implementations. Several internal optimizations improve performance cpp11, particularly vector operations memory management. optimizations maintain safety guarantees cpp11 improving execution speed. cpp4r provides full bidirectional copy complex numbers, enabling seamless copy complex vectors matrices R C++ code. contrary, cpp11 support copying complex numbers R C++ vice versa. cpp4r maintains cpp11’s core design principles extending functionality: Copy--Write Semantics: Like cpp11, cpp4r enforces copy--write semantics match R’s behavior, preventing unexpected modifications input data. Safety First: cpp4r incorporates comprehensive safety mechanisms interfacing R’s C API, using unwind_protect() exception handling prevent resource leaks. Modern C++ Features: implementation leverages C++11 features including move semantics, type traits, variadic templates, user-defined literals. Header-Design: completely header-library, cpp4r avoids ABI compatibility issues can arise libraries containing compiled components. cpp4r offers vendoring capabilities, means copy code dependencies project’s source tree. idea comes Go programming language, common practice included dependencies’ headers source code (Go Authors 2024). ensures dependency code fixed stable updated. feature possible cpp4r header-library, allowing copy headers running cpp4r::vendor_cpp4r() need option. Vendoring advantages drawbacks however. advantage unlikely disruptive changes cpp4r project never break existing code. drawbacks package size slightly larger isolated bugfixes /new features explicitly update vendored headers. majority packages vendor cpp4r dependency, unless designed run within restricted environments internet access limited unavailable security reasons (e.g., high-performance computing clusters).","code":""},{"path":"./articles/01-motivations.html","id":"software-functionalities","dir":"Articles","previous_headings":"","what":"Software functionalities","title":"01 - Motivations for cpp4r","text":"cpp4r designed drop-replacement cpp11, using identical syntax API patterns. Existing cpp11 code can typically migrated cpp4r minimal changes, primarily involving header includes namespace references. use cpp4r, users must first install package CRAN GitHub. following code shows install package: installed, users can use provided package template function create new package uses C++ code. package template includes simple examples necessary files compile code install new R package. following code shows create new package: package skeleton includes standard practices: C++ functions exposed R using attribute syntax documented roxygen comments: equivalent cpp11 code :","code":"install.packages(\"cpp4r\", repos = \"https://cran.rstudio.com\")  # or remotes::install_github(\"pachadotdev/cpp4r\") cpp4r::pkg_template(\"~/rstats/mypkg\") # In DESCRIPTION file LinkingTo: cpp4r  # In R code #' @useDynLib mypkg, .registration = TRUE #' @keywords internal \"_PACKAGE\" /* roxygen @title Square of Each Element in 'x' @param x Numeric vector @return Numeric vector @export */ [[cpp4r::register]] cpp4r::doubles my_square(cpp4r::doubles x) {   return x * x; } [[cpp11::register]] cpp11::doubles my_square_cpp(cpp11::doubles x) {   return x * x; } #' @title Square of Each Element in 'x #' @param x Numeric vector #' @return Numeric vector #' @export my_square <- function(x) {   my_square_cpp(x) }"},{"path":"./articles/01-motivations.html","id":"illustrative-examples","dir":"Articles","previous_headings":"","what":"Illustrative examples","title":"01 - Motivations for cpp4r","text":"cpp4r uses custom double linked list data structure track objects managing. structure efficient large numbers objects using R_PreserveObject()/R_ReleaseObjects() done Rcpp. problems know vectors matrices size beforehand, performance difference cpp4r/cpp11 Rcpp negligible. However, length vectors (matrices) known beforehand, performance changes notably, case rejection sampling algorithm consists obtaining nn accepted samples without possibility know beforehand many candidates need generate. C++ push_back() method ideal cases rejection sampling, candidate either accepted (stored) rejected (discarded), low acceptance rates might need generate knkn candidates (k>1k > 1) nn final samples. Unlike Gibbs sampling algorithms, know iterations upfront, rejection sampling genuinely requires dynamic growth vectors matrices. example, acceptance rate 80%, need generate approximately 1.25n1.25 n samples obtain nn final samples. Rejection sampling used Monte Carlo methods, Bayesian inference, simulation studies cpp4r design handy reserves extra memory making push_back() operations within time complexity O(1)O(1). contrary, Rcpp reserve extra capacity push_back() operations time complexity O(n)O(n) leads quadratic pattern memory usage number input elements. design difference translates performance differences larger input data. following code shows rejection sampling implementation lower upper truncation bounds using cpp4r (equivalent cpp11 Rcpp): following table shows speed quantiles rejection sampling algorithm implemented cpp4r, cpp11, Rcpp: benchmark reveals cpp4r cpp11 exhibit better scaling compared Rcpp, showing different approach makes difference require repeated calls push_back(), Rcpp entire vector copied call. contrast cpp4r vectors grow efficiently, reserving extra space std::vector .","code":"// Reproducible examples via set.seed() in R class local_rng {  public:   local_rng() { GetRNGstate(); }   ~local_rng() { PutRNGstate(); } };  [[cpp4r::register]] doubles rejection_sampling_cpp4r(int n_samples, double mu = 0.0,                                                       double sigma = 1.0,                                                      double lower = -2.0,                                                       double upper = 2.0) {   local_rng rng_state;      // Acceptance rate for better initial allocation   double z_lower = (lower - mu) / sigma, z_upper = (upper - mu) / sigma;   double acceptance_rate = Rf_pnorm5(z_upper, 0.0, 1.0, 1, 0) -     Rf_pnorm5(z_lower, 0.0, 1.0, 1, 0);      // Allocate based on expected number of samples needed (add 20% to ensure minimum size)   R_xlen_t estimated_needed = static_cast<R_xlen_t>(n_samples / acceptance_rate * 1.2);   estimated_needed = std::max(estimated_needed, static_cast<R_xlen_t>(n_samples));      writable::doubles accepted_samples;   accepted_samples.reserve(estimated_needed);      // Keep sampling until we have enough accepted samples   int target_samples = static_cast<int>(n_samples);      while (static_cast<int>(accepted_samples.size()) < target_samples) {     double candidate = Rf_rnorm(mu, sigma);          if (candidate >= lower && candidate <= upper) {       accepted_samples.push_back(candidate);     }   }      return accepted_samples; } library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(purrr) library(scales) #>  #> Attaching package: 'scales' #> The following object is masked from 'package:purrr': #>  #>     discard library(bench) library(kableExtra) #>  #> Attaching package: 'kableExtra' #> The following object is masked from 'package:dplyr': #>  #>     group_rows  rejection_bench <- readRDS(\"rejection_bench.rds\")  rejection_bench <- rejection_bench %>%   select(expression, len, median, mem_alloc) %>%   mutate(     expression = as.character(expression),     len = formatC(len, format = \"d\", big.mark = \",\")   ) %>%   mutate(     expression = factor(expression, levels = c(\"cpp4r\", \"cpp11\", \"Rcpp\")),     len = factor(len, levels = c(\"25,000\", \"50,000\", \"75,000\", \"100,000\")),   ) %>%   arrange(expression, len)  rejection_bench %>%   knitr::kable(align = c(\"l\", rep(\"r\", 3)), booktabs = TRUE,     col.names = c(\"Backend\", \"Sample size\", \"Median speed\", \"Cumulative memory usage\")) %>%   kable_styling(latex_options = c(\"hold_position\")) %>%   collapse_rows(columns = 1, valign = \"middle\", latex_hline = \"major\")"},{"path":"./articles/01-motivations.html","id":"impact","dir":"Articles","previous_headings":"","what":"Impact","title":"01 - Motivations for cpp4r","text":"providing portable interface C++ integration, cpp4r enables R developers leverage power modern C++ minimizing complexity typically associated writing compiled code. benchmarks demonstrate substantial speed memory usage improvements compared existing implementations, providing researchers useful tool write R packages analyze large datasets intensive computations. Besides better use RAM, can make difference able run analysis , cpp4r’s design also offers faster compilation times, can significantly enhance development workflow testing. particularly beneficial academic business settings, prototyping iteration often precede final implementation. cpp4r represents evolution C++ bindings R, building upon solid foundation established cpp11 addressing specific limitations adding features can benefit R community. maintaining API compatibility cpp11, cpp4r provides migration path developers seeking enhanced functionality without requiring significant code restructuring.","code":""},{"path":"./articles/01-motivations.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"01 - Motivations for cpp4r","text":"development cpp4r demonstrates value open-source transparency enabled derived works. cpp11 Rcpp continue serve broader R community effectively, cpp4r offers alternative projects requiring specific enhancements, particularly academic research contexts documentation features additional data types support reduces coding effort advancing computational methods.","code":""},{"path":[]},{"path":"./articles/02-setup.html","id":"c-setup","dir":"Articles","previous_headings":"","what":"C++ Setup","title":"02 - Setup","text":"need working C++ compiler capable compiling C++11 code. get : Windows, install Rtools. Mac, install Xcode App Store. Linux, sudo pacman -Syu install build-essential g++-11 similar.","code":""},{"path":"./articles/02-setup.html","id":"for-ubuntu-users","dir":"Articles","previous_headings":"C++ Setup","what":"For Ubuntu Users","title":"02 - Setup","text":"installing g++-11, may still encounter issues compiling C++ code due missing standard library headers. happen testing Manjaro Linux. can try : can attempt compile simple example print number: try compile run following bash instruction: Otherwise, installing additional packages may lead following error:","code":"sudo apt install build-essential g++-11 libc++-11-dev libc++abi-11-dev // save this as 01-print-number.cpp or similar #include <iostream> // required for the cout function  // function to print a message int main() {     std::cout << 1 << std::endl;     return 0; } g++ 01-print-number.cpp ./01-print-number # prints \"1\" fatal error: 'cstdio' file not found fatal error: 'vector' file not found cannot find -lc++abi: No such file or directory"},{"path":"./articles/02-setup.html","id":"r-setup","dir":"Articles","previous_headings":"","what":"R Setup","title":"02 - Setup","text":"can install R packages bench, cpp4r, devtools usethis following command: verify R can compile C++ code, can run pkgbuild::check_build_tools(debug = TRUE), return output similar :","code":"install.packages(c(\"bench\", \"cpp4r\", \"devtools\", \"usethis\")) Trying to compile a simple C file Running /usr/lib64/R/bin/R CMD SHLIB foo.c using C compiler: ‘gcc (GCC) 15.2.1 20250813’"},{"path":"./articles/03-package-skeleton.html","id":"loading-the-required-r-packages","dir":"Articles","previous_headings":"","what":"Loading the Required R Packages","title":"03 - Package Skeleton","text":"vignette next use following R packages:","code":"library(cpp4r) library(devtools) library(bench) library(usethis)"},{"path":"./articles/03-package-skeleton.html","id":"creating-a-dummy-package","dir":"Articles","previous_headings":"","what":"Creating a Dummy Package","title":"03 - Package Skeleton","text":"can create new package RStudio (VSCode) running: command create new folder containing cpp4rexamples package. Afterward, can run use_cpp4r() add necessary code package.","code":"pkg_template(\"~/github/cpp4r/cpp4rexamples\")"},{"path":"./articles/03-package-skeleton.html","id":"print-a-number","dir":"Articles","previous_headings":"","what":"Print a Number","title":"03 - Package Skeleton","text":"pkg_template() function automatically creates ./cpp4rexamples/R/cpp4rexamples-package.R following content: also creates ./cpp4rexamples/src/main.cpp. rest src/ aims provide organization keep code organized different files according purpose. Give look ./cpp4rexamples/src/01_plus_one.h, contains following C++ code: code called main.cpp makes sense keep organization codebase grows, otherwise can end single large cpp file containing thousands lines code harder maintain. R packages, need create main() function C++, entry point standalone C++ program. Unlike cpp11, cpp4r can document C++ functions using roxygen2 comments. comments must placed [[cpp4r::register]] attribute. cpp11, need write separate wrapper, like : R version previous function follows: use C++ function, can register document running: print: development live testing, use load_all(): Try plus_two(1) plus_two(1.0). 1 1.0 matter C++?","code":"#' @useDynLib cpp4rexamples, .registration = TRUE #' @keywords internal \"_PACKAGE\" /* roxygen @title Plus 1 (C++) @param x integer @description It adds 1 to an integer value. @export @examples plus_one(1) */ [[cpp4r::register]] int plus_one(int x) {   return x + 1; } [[cpp4r::register]] int plus_one_(int x) {   return x + 1; } #' @title Plus 1 (C++) #' @param x integer #' @description It adds 1 to an integer value. #' @export #' @examples plus_one(1) plus_one <- function(x) {   plus_one_(x) } #' Plus one (R) #' @param x integer #' @description It adds 1 to an integer value. #' @export #' @examples plus_one_r(1) plus_one_r <- function(x) {   x + 1 } cpp4r::register() devtools::document() devtools::load_all() > plus_one(1) [1] 2 load_all()"},{"path":"./articles/03-package-skeleton.html","id":"numbers-sign","dir":"Articles","previous_headings":"","what":"Number’s Sign","title":"03 - Package Skeleton","text":"complex function one returns sign number: Add function new file src/03_sign.h. R version function: forget include new header file main.cpp. Document functions compare outputs.","code":"[[cpp4r::register]] int sign_cpp(double x) {   if (x > 0) {     return 1;   } else if (x == 0) {     return 0;   } else {     return -1;   } } sign_r <- function(x) {   if (x > 0) {     1   } else if (x == 0) {     0   } else {     -1   } }"},{"path":"./articles/03-package-skeleton.html","id":"installing-the-package","dir":"Articles","previous_headings":"","what":"Installing the Package","title":"03 - Package Skeleton","text":"document install package R library, can run following functions: Afterward, can access functions loading package library(cpp4rexamples). time need make changes C++ code, can run load_all() test reinstall package.","code":"cpp4r::register() devtools::document() devtools::install()"},{"path":"./articles/03-package-skeleton.html","id":"good-practice","dir":"Articles","previous_headings":"","what":"Good Practice","title":"03 - Package Skeleton","text":"good practice include license code. example, can use Apache license running: Additionally, recommended use use_build_ignore() ignore files unnecessary package installation. example, ignore docs folder, can run: .Rbuildignore file can include following lines, can edit manually exclude specific files directories:","code":"usethis::use_apache_license() usethis::use_build_ignore(\"docs\") ^\\.vscode$ ^LICENSE\\.md$ ^cpp4rexamples\\.Rproj$"},{"path":[]},{"path":"./articles/04-read-only.html","id":"read-and-write","dir":"Articles","previous_headings":"","what":"Read and write","title":"04 - Read-only versus Writable R Objects","text":"cpp4r, declare variable, read-default cpp11 (vaughan?). different Rcpp, variables read-write default (rcpp?). Following package created previous vignette, try compile run following code adding new file src/04_square_coordinates.h: devtools::load_all() devtools::install() fail following error: argument x read-object, need explicitly declare writable variable: Alternatively, can declare argument writable: forget include new header file main.cpp: Document functions roxygen compare outputs loading updated package: Compare square_coordinates(1:3), square_coordinates(c(1, 2, 3)), square_coordinates(c(1L, 2L, 3L)). outputs differ? integers doubles interchangeable double int C++ reasonable cases?","code":"[[cpp4r::register]] integers square_coordinates_(integers x) {   integers out = x;   for (int i = 0; i < x.size(); ++i) {     out[i] = x[i] * x[i];   }   return out; } error: lvalue required as left operand of assignment   out[i] = x[i] * x[i]; [[cpp4r::register]] integers square_coordinates(integers x) {   writable::integers out = x;   for (int i = 0; i < x.size(); ++i) {     out[i] = x[i] * x[i];   }   return out; } [[cpp4r::register]] integers square_coordinates_2(writable::integers x) {   for (int i = 0; i < x.size(); ++i) {     x[i] = x[i] * x[i];   }   return x; } cpp4r::register() devtools::document() devtools::load_all()"},{"path":[]},{"path":"./articles/05-logical-functions.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"05 - Logical Functions","text":"functions ignore NA values now. Adjustments handling NA values covered separate vignette. R already provides efficient versions functions covered . just illustrate use C++ code.","code":""},{"path":"./articles/05-logical-functions.html","id":"is-any-value-in-a-vector-true","dir":"Articles","previous_headings":"","what":"Is any value in a vector ‘true’?","title":"05 - Logical Functions","text":"Base R’s () function returns TRUE least one TRUE element vector, FALSE otherwise. one possible C++ implementation: R equivalent : Add document functions, update package previous vignettes, compare functions speed :","code":"[[cpp4r::register]] bool any_cpp(logicals x) {   int n = x.size();      for (int i = 0; i < n; ++i) {     if (x[i]) {       return true;     }   }   return false; } any_r <- function(x) {   n <- length(x)      for (i in 1:n) {     if (x[i]) {       return(TRUE)     }   }   FALSE } # install.packages(\"bench\") library(bench)  set.seed(123) # for reproducibility x <- rpois(1e6, lambda = 2) # 1,000,000 elements y <- ifelse(x > 2, TRUE, FALSE)  any(y) any_cpp(y) any_r(y)  mark(   any(y),   any_cpp(y),   any_r(y) )"},{"path":"./articles/05-logical-functions.html","id":"which-elements-in-a-vector-are-true","dir":"Articles","previous_headings":"","what":"Which elements in a vector are ‘true’?","title":"05 - Logical Functions","text":"Base R’s () function returns indices TRUE elements vector. possible C++ implementation: R equivalent : test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] integers which_cpp(logicals x) {   int n = x.size();   writable::integers res;   int j = 0;    for (int i = 0; i < n; ++i) {     if (x[i]) {       ++j;       res.push_back(i + 1);     }   }    if (j == 0) {     return integers(0);   } else {     return res;   } } which_r <- function(x) {   n <- length(x)   res <- c()   j <- 0    for (i in 1:n) {     if (x[i]) {       res <- c(res, i)       j <- j + 1     }   }    if (j == 0) {     return(0)   } else {     return(res)   } } which(y[1:100]) which_cpp(y[1:100]) which_r(y[1:100])  mark(   which(y[1:1000]),   which_cpp(y[1:1000]),   which_r(y[1:1000]) )"},{"path":"./articles/05-logical-functions.html","id":"are-all-values-in-a-vector-true","dir":"Articles","previous_headings":"","what":"Are all values in a vector ‘true’?","title":"05 - Logical Functions","text":"Base R’s () function checks elements vector TRUE. possible C++ implementation loops vector: concise C++ alternatives : avoid typing std:: every time, can use using namespace std; top src/code.cpp. However, recommended can lead conflicts. better option declare using std::the_function; means can use the_function instead std::the_function time (akbiggs?). However, recommended can lead conflicts two functions name. test functions, can run following tests benchmark code R console:","code":"[[cpp4r::register]] bool all_cpp_1(logicals x) {   int n = x.size();   for (int i = 0; i < n; ++i) {     if (!x[i]) {       return false;     }   }   return true; } [[cpp4r::register]] bool all_cpp_2(logicals x) {   for (int i = 0; i < x.size(); ++i) {     if (!x[i]) {       return false;     }   }   return true; }  [[cpp4r::register]] bool all_cpp_3(logicals x) {   for (bool i : x) {     if (!i) {       return false;     }   }   return true; }  [[cpp4r::register]] bool all_cpp_4(logicals x) {   return std::all_of(x.begin(), x.end(), [](bool x) { return x; }); } set.seed(123) # for reproducibility x <- rpois(1e6, lambda = 2) # 1,000,000 elements  all(x > 2) all_cpp_1(x > 2) all_cpp_2(x > 2) all_cpp_3(x > 2) all_cpp_4(x > 2)  # also test the TRUE-only case all(x >= 0) all_cpp_1(x >= 0) all_cpp_2(x >= 0) all_cpp_3(x >= 0) all_cpp_4(x >= 0) mark(   all(x > 2),   all_cpp_1(x > 2),   all_cpp_2(x > 2),   all_cpp_3(x > 2),   all_cpp_4(x > 2) )"},{"path":[]},{"path":"./articles/06-rolling-functions.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"06 - Rolling Functions","text":"functions ignore NA values now. Adjustments handling NA values covered separate vignette. R already provides efficient versions functions covered . just illustrate use C++ code.","code":""},{"path":"./articles/06-rolling-functions.html","id":"cumulative-sum","dir":"Articles","previous_headings":"","what":"Cumulative sum","title":"06 - Rolling Functions","text":"Base R provides cumsum() function compute cumulative sum vector: One possible C++ function implement : R equivalent : Add document functions, update package previous vignettes, compare functions speed :","code":"cumsum(1:5) [[cpp4r::register]] doubles cumsum_cpp(doubles x) {   int n = x.size();   writable::doubles out(n);    out[0] = x[0];   for (int i = 1; i < n; ++i) {     out[i] = out[i - 1] + x[i];   }   return out; } cumsum_r <- function(x) {   n <- length(x)   out <- numeric(n)   out[1] <- x[1]   for (i in 2:n) {     out[i] <- out[i - 1] + x[i]   }   out } # install.packages(\"bench\") library(bench)  set.seed(123) # for reproducibility x <- rpois(1e6, lambda = 2) # 1,000,000 elements  cumsum(1:3) cumsum_cpp(1:3) cumsum_r(1:3)  mark(   cumsum(x),   cumsum_cpp(x),   cumsum_r(x) )"},{"path":"./articles/06-rolling-functions.html","id":"cumulative-product","dir":"Articles","previous_headings":"","what":"Cumulative product","title":"06 - Rolling Functions","text":"Base R provides cumprod() function compute cumulative product vector: One possible C++ function implement : R equivalent : test functions, can run following benchmark code R console:","code":"cumprod(1:5) [[cpp4r::register]] doubles cumprod_cpp(doubles x) {   int n = x.size();   writable::doubles out(n);    out[0] = x[0];   for (int i = 1; i < n; ++i) {     out[i] = out[i - 1] * x[i];   }   return out; } cumprod_r <- function(x) {   n <- length(x)   out <- numeric(n)   out[1] <- x[1]   for (i in 2:n) {     out[i] <- out[i - 1] * x[i]   }   out } mark(   cumprod(x),   cumprod_cpp(x),   cumprod_r(x) )"},{"path":"./articles/06-rolling-functions.html","id":"range-of-values","dir":"Articles","previous_headings":"","what":"Range of values","title":"06 - Rolling Functions","text":"simple example range() function R : One possible C++ function implement : Write R equivalent. verify functions, can run following tests benchmark code R console:","code":"range(x) [[cpp4r::register]] doubles range_cpp(doubles x) {   int n = x.size();   double x1 = x[0], x2 = x[0];    for (int i = 1; i < n; ++i) {     x1 = std::min(x1, x[i]);     x2 = std::max(x2, x[i]);   }    writable::doubles out(2);   out[0] = x1;   out[1] = x2;    return out; } # install.packages(\"purrr\") # install.packages(\"dplyr\") # install.packages(\"ggplot2\") # install.packages(\"patchwork\") library(purrr) library(dplyr) library(ggplot2) library(patchwork)  range(x) range_cpp(x) # range_r(x)  # create random vectors set.seed(123) # for reproducibility bigx <- list(   as.double(rpois(2e6, lambda = 2)),   as.double(rpois(4e6, lambda = 2)),   as.double(rpois(8e6, lambda = 2)),   as.double(rpois(16e6, lambda = 2)),   as.double(rpois(32e6, lambda = 2)),   as.double(rpois(64e6, lambda = 2)) )  results <- map(   bigx,   ~ mark(     range(.x),     range_cpp(.x)     # range_r(.x)   ) %>%     mutate(n = length(.x)) )  d <- results %>%   bind_rows() %>%   unnest(c(time, mem_alloc, gc, n)) %>%   select(expression, time, mem_alloc, gc, n)  g1 <- ggplot(d, aes(x = n, y = time, color = expression)) +   geom_jitter(width = 0.01, height = 0.01) +   scale_color_viridis_d() +   theme_minimal()  g2 <- ggplot(d, aes(x = n, y = mem_alloc, color = expression)) +   geom_jitter(width = 0.01, height = 0.01) +   scale_color_viridis_d() +   theme_minimal()  g1 / g2"},{"path":[]},{"path":"./articles/07-statistical-functions.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"07 - Statistical Functions","text":"functions ignore NA values now. Adjustments handling NA values covered separate vignette. R already provides efficient versions functions covered . just illustrate use C++ code. explanations equations used functions taken (diez?) (hansen?). examples adapted (vaughan?).","code":""},{"path":"./articles/07-statistical-functions.html","id":"sum","dir":"Articles","previous_headings":"","what":"Sum","title":"07 - Statistical Functions","text":"vector nn elements x1,x2,…,xnx_1, x_2, \\ldots, x_n, sum calculated : ∑=1nxi=x1+x2+…+xn \\sum_{=1}^{n} x_i = x_1 + x_2 + \\ldots + x_n following C++ function calculates sum vector’s elements: R equivalent : Document functions update package previous vignettes. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double sum_cpp(doubles x) {   int n = x.size();   double total = 0;   for(int i = 0; i < n; ++i) {     total += x[i];   }   return total; } sum_r <- function(x) {   total <- 0   for (i in seq_along(x)) {     total <- total + x[i]   }   total } # install.packages(\"bench\") library(bench)  set.seed(123) # for reproducibility x <- runif(1e3) # 1,000,000 elements  sum(x) sum_cpp(x) sum_r(x)  mark(   sum(x),   sum_cpp(x),   sum_r(x) )"},{"path":"./articles/07-statistical-functions.html","id":"arithmetic-mean","dir":"Articles","previous_headings":"","what":"Arithmetic mean","title":"07 - Statistical Functions","text":"arithmetic mean vector nn elements x1,x2,…,xnx_1, x_2, \\ldots, x_n calculated : x‾=1n∑=1nxi \\bar{x} = \\frac{1}{n} \\sum_{=1}^{n} x_i following C++ function calculates mean vector’s elements: R equivalent : Document functions update package previous vignettes. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double mean_cpp(doubles x) {   int n = x.size();   double y = 0;    for(int i = 0; i < n; ++i) {     y += x[i];   }   return y / n; } mean_r <- function(x) {   sum_r(x) / length(x) } mean(x) mean_cpp(x) mean_r(x)  mark(   mean(x),   mean_cpp(x),   mean_r(x) )"},{"path":"./articles/07-statistical-functions.html","id":"variance","dir":"Articles","previous_headings":"","what":"Variance","title":"07 - Statistical Functions","text":"variance vector nn elements x1,x2,…,xnx_1, x_2, \\ldots, x_n calculated : Var(x)=1n−1∑=1n(xi−x‾)2 \\text{Var}(x) = \\frac{1}{n-1} \\sum_{=1}^{n} (x_i - \\bar{x})^2 following C++ function calculates variance vector’s elements: R equivalent : Document functions update package previous vignettes. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double var_cpp(doubles x) {   int n = x.size();   double y1 = 0, y2 = 0;    for(int i = 0; i < n; ++i) {     y1 += x[i];     y2 += pow(x[i], 2.0);   }   return (y2 - pow(y1, 2.0) / n) / (n - 1); } var_r <- function(x) {   mean_r((x - mean_r(x))^2) } var(x) var_cpp(x) var_r(x)  mark(   var(x),   var_cpp(x),   var_r(x) )"},{"path":"./articles/07-statistical-functions.html","id":"root-mean-square-error-rmse","dir":"Articles","previous_headings":"","what":"Root Mean Square Error (RMSE)","title":"07 - Statistical Functions","text":"RMSE function measures differences observed values true value. vector nn elements x1,x2,…,xnx_1, x_2, \\ldots, x_n value x0x_0, RMSE calculated : RMSE(x,x0)=1n∑=1n(xi−x0)2 \\text{RMSE}(x, x_0) = \\sqrt{\\frac{1}{n} \\sum_{=1}^{n} (x_i - x_0)^2} following C++ function calculates difference vector’s elements value returns square root mean squared differences: R equivalent : Document functions update package previous vignettes. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double rmse_cpp(doubles x, double x0) {   int n = x.size();   double y = 0;   for (int i = 0; i < n; ++i) {     y += pow(x[i] - x0, 2.0);   }   return sqrt(y / n); } #' Return the root mean square error (R) #' @param x numeric vector #' @param x0 numeric value #' @export rmse_r <- function(x, x0) {   sqrt(sum((x - x0)^2) / length(x)) } # create a list with 100 normal distributions with mean 0 and 1 million elements set.seed(123) x <- list() for (i in 1:1e3) {   x[[i]] <- rnorm(1e3) }  # compute the mean of each distribution x <- sapply(x, mean)  rmse_cpp(x, 0) rmse_r(x, 0)  mark(   rmse_cpp(x, 0),   rmse_r(x, 0) )"},{"path":[]},{"path":"./articles/08-logical-functions-2.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"08 - Logical Functions with Missing Values","text":"functions ignore NA values now. Adjustments handling NA values covered separate vignette. R already provides efficient versions functions covered . just illustrate use C++ code.","code":""},{"path":"./articles/08-logical-functions-2.html","id":"is-any-value-in-a-vector-true","dir":"Articles","previous_headings":"","what":"Is any value in a vector ‘true’?","title":"08 - Logical Functions with Missing Values","text":"following function expands previous any_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] bool any2_cpp(logicals x, bool na_rm = false) {   int n = x.size();   bool has_na = false;      for (int i = 0; i < n; ++i) {     if (x[i] == NA_LOGICAL) {       has_na = true;       if (!na_rm) {         continue; // Skip NA values if na_rm is false       }     } else if (x[i]) {       return true;     }   }      // If we found any NA and na_rm is false, return NA   if (has_na && !na_rm) {     return NA_LOGICAL;   }      return false; } set.seed(123) # for reproducibility x <- rpois(1e6, lambda = 2) # 1,000,000 elements y <- ifelse(x > 2, TRUE, FALSE)  any(c(TRUE, NA, FALSE)) any2_cpp(c(TRUE, NA, FALSE)) any2_cpp(c(TRUE, NA, FALSE), na_rm = TRUE)  mark(   any(y),   any2_cpp(y) )"},{"path":"./articles/08-logical-functions-2.html","id":"which-elements-in-a-vector-are-true","dir":"Articles","previous_headings":"","what":"Which elements in a vector are ‘true’?","title":"08 - Logical Functions with Missing Values","text":"following function expands previous which_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] integers which2_cpp(logicals x, bool na_rm = false) {   int n = x.size();   writable::integers res;   int j = 0;    for (int i = 0; i < n; ++i) {     if (x[i] == NA_LOGICAL) {       if (!na_rm) {         // Skip NA values if na_rm is false         continue;       }     } else if (x[i]) {       ++j;       res.push_back(i + 1);     }   }    if (j == 0) {     return integers(0);   } else {     return res;   } } which(c(TRUE, NA, FALSE, TRUE)) which2_cpp(c(TRUE, NA, FALSE, TRUE)) which2_cpp(c(TRUE, NA, FALSE, TRUE), na_rm = TRUE)  mark(   which(y[1:1000]),   which2_cpp(y[1:1000]) )"},{"path":"./articles/08-logical-functions-2.html","id":"are-all-values-in-a-vector-true","dir":"Articles","previous_headings":"","what":"Are all values in a vector ‘true’?","title":"08 - Logical Functions with Missing Values","text":"following function expands previous all_cpp() function handle missing values. concise C++ alternatives : test functions, can run following tests benchmark code R console:","code":"[[cpp4r::register]] bool all2_cpp_1(logicals x, bool na_rm = false) {   int n = x.size();   bool has_na = false;      for (int i = 0; i < n; ++i) {     if (x[i] == NA_LOGICAL) {       has_na = true;       if (!na_rm) {         continue; // Skip NA values if na_rm is false       }     } else if (!x[i]) {       return false;     }   }      // If we found any NA and na_rm is false, return NA   if (has_na && !na_rm) {     return NA_LOGICAL;   }      return true; } [[cpp4r::register]] bool all2_cpp_2(logicals x, bool na_rm = false) {   bool has_na = false;      for (int i = 0; i < x.size(); ++i) {     if (x[i] == NA_LOGICAL) {       has_na = true;       if (!na_rm) {         continue;       }     } else if (!x[i]) {       return false;     }   }      if (has_na && !na_rm) {     return NA_LOGICAL;   }      return true; }  [[cpp4r::register]] bool all2_cpp_3(logicals x, bool na_rm = false) {   bool has_na = false;      for (int i = 0; i < x.size(); ++i) {     if (x[i] == NA_LOGICAL) {       has_na = true;       if (!na_rm) {         continue;       }     } else if (!x[i]) {       return false;     }   }      if (has_na && !na_rm) {     return NA_LOGICAL;   }      return true; } set.seed(123) # for reproducibility x <- rpois(1e6, lambda = 2) # 1,000,000 elements  all(c(TRUE, NA, TRUE)) all2_cpp_1(c(TRUE, NA, TRUE)) all2_cpp_1(c(TRUE, NA, TRUE), na_rm = TRUE)  all(c(FALSE, NA, TRUE)) all2_cpp_1(c(FALSE, NA, TRUE)) all2_cpp_1(c(FALSE, NA, TRUE), na_rm = TRUE)  # also test the TRUE-only case all(x >= 0) all2_cpp_1(x >= 0) all2_cpp_2(x >= 0) all2_cpp_3(x >= 0) mark(   all(x > 2),   all2_cpp_1(x > 2),   all2_cpp_2(x > 2),   all2_cpp_3(x > 2) )"},{"path":[]},{"path":"./articles/09-rolling-functions-2.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"09 - Rolling Functions with Missing Values","text":"functions ignore NA values now. Adjustments handling NA values covered separate vignette. R already provides efficient versions functions covered . just illustrate use C++ code.","code":""},{"path":"./articles/09-rolling-functions-2.html","id":"cumulative-sum","dir":"Articles","previous_headings":"","what":"Cumulative sum","title":"09 - Rolling Functions with Missing Values","text":"following function expands previous cumsum_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] doubles cumsum2_cpp(doubles x, bool na_rm = false) {   int n = x.size();    writable::doubles out(n);   out[0] = x[0];    if (na_rm == true) {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y2)) {         out[i] = y1 + 0.0;       } else {         if (ISNAN(y1)) {           out[i] = 0.0 + y2;         } else {           out[i] = y1 + y2;         }       }     }   } else {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y2)) {         out[i] = NA_REAL;       } else {         if (ISNAN(y1)) {           out[i] = NA_REAL;         } else {           out[i] = y1 + y2;         }       }     }   }    return out; } set.seed(123) # for reproducibility x <- rpois(1e6, lambda = 2) # 1,000,000 elements  cumsum(c(1, NA, 2, 4)) cumsum2_cpp(c(1, NA, 2, 4)) cumsum2_cpp(c(1, NA, 2, 4), na_rm = TRUE)  mark(   cumsum(x),   cumsum2_cpp(x) )"},{"path":"./articles/09-rolling-functions-2.html","id":"cumulative-product","dir":"Articles","previous_headings":"","what":"Cumulative product","title":"09 - Rolling Functions with Missing Values","text":"following function expands previous cumprod_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] doubles cumprod2_cpp(doubles x, bool na_rm = false) {   int n = x.size();    writable::doubles out(n);   out[0] = x[0];    if (na_rm == true) {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y2)) {         out[i] = y1 * 1.0;       } else {         if (ISNAN(y1)) {           out[i] = 1.0 * y2;         } else {           out[i] = y1 * y2;         }       }     }   } else {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y2)) {         out[i] = NA_REAL;       } else {         if (ISNAN(y1)) {           out[i] = NA_REAL;         } else {           out[i] = y1 * y2;         }       }     }   }    return out; } cumprod(c(1, NA, 2, 4)) cumprod2_cpp(c(1, NA, 2, 4)) cumprod2_cpp(c(1, NA, 2, 4), na_rm = TRUE)  mark(   cumprod(x),   cumprod2_cpp(x) )"},{"path":"./articles/09-rolling-functions-2.html","id":"cumulative-minimum","dir":"Articles","previous_headings":"","what":"Cumulative minimum","title":"09 - Rolling Functions with Missing Values","text":"next function calculates cumulative minimum elements vector. test function, can run following benchmark code R console:","code":"[[cpp4r::register]] doubles cummin_cpp(doubles x, bool na_rm = false) {   int n = x.size();    writable::doubles out(n);   out[0] = x[0];    if (na_rm == true) {     for (int i = 1; i < n; ++i) {       double y1 = x[i - 1], y2 = x[i];       if (ISNAN(y1)) {         out[i] = y2;       } else {         out[i] = std::min(y1, y2);       }     }   } else {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y2)) {         out[i] = NA_REAL;       } else {         if (ISNAN(y1)) {           out[i] = NA_REAL;         } else {           out[i] = std::min(y1, y2);         }       }     }   }    return out; } cummin(c(1, NA, 2, 4)) cummin_cpp(c(1, NA, 2, 4)) cummin_cpp(c(1, NA, 2, 4), na_rm = TRUE)  mark(   cummin(x),   cummin_cpp(x) )"},{"path":"./articles/09-rolling-functions-2.html","id":"cumulative-maximum","dir":"Articles","previous_headings":"","what":"Cumulative maximum","title":"09 - Rolling Functions with Missing Values","text":"next function calculates cumulative maximum elements vector. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] doubles cummax_cpp(doubles x, bool na_rm = false) {   int n = x.size();    writable::doubles out(n);   out[0] = x[0];    if (na_rm == true) {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y1)) {         out[i] = y2;       } else {         out[i] = std::max(y1, y2);       }     }   } else {     for (int i = 1; i < n; ++i) {       double y1 = out[i - 1], y2 = x[i];       if (ISNAN(y2)) {         out[i] = NA_REAL;       } else {         if (ISNAN(y1)) {           out[i] = NA_REAL;         } else {           out[i] = std::max(y1, y2);         }       }     }   }    return out; } cummax(c(1, NA, 2, 4)) cummax_cpp(c(1, NA, 2, 4)) cummax_cpp(c(1, NA, 2, 4), na_rm = TRUE)  mark(   cummax(x),   cummax_cpp(x) )"},{"path":[]},{"path":"./articles/10-statistical-functions-2.html","id":"note","dir":"Articles","previous_headings":"","what":"Note","title":"10 - Statistical Functions with Missing Values","text":"functions ignore NA values now. Adjustments handling NA values covered separate vignette. R already provides efficient versions functions covered . just illustrate use C++ code.","code":""},{"path":"./articles/10-statistical-functions-2.html","id":"sum","dir":"Articles","previous_headings":"","what":"Sum","title":"10 - Statistical Functions with Missing Values","text":"following function expands previous sum_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double sum2_cpp(doubles x, bool na_rm = false) {   int n = x.size();   double total = 0;   for (int i = 0; i < n; ++i) {     if (na_rm && ISNAN(x[i])) {       continue;     } else {       total += x[i];     }   }   return total; } set.seed(123) # for reproducibility x <- runif(1e3) # 1,000 elements x[sample(1:1e3, 1e2)] <- NA # randomly insert NA values  sum(x, na.rm = FALSE) sum2_cpp(x, na_rm = FALSE)  sum(x, na.rm = TRUE) sum2_cpp(x, na_rm = TRUE)  mark(   sum(x, na.rm = TRUE),   sum2_cpp(x, na_rm = TRUE) )"},{"path":"./articles/10-statistical-functions-2.html","id":"arithmetic-mean","dir":"Articles","previous_headings":"","what":"Arithmetic mean","title":"10 - Statistical Functions with Missing Values","text":"following function expands previous mean_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double mean2_cpp(doubles x, bool na_rm = false) {   int n = x.size();   int m = 0;      for (int i = 0; i < n; ++i) {     if (na_rm && ISNAN(x[i])) {       continue;     } else {       ++m;     }   }    if (m == 0) {     return NA_REAL;   }    double total = 0;   for (int i = 0; i < n; ++i) {     if (na_rm && ISNAN(x[i])) {       continue;     } else {       total += x[i];     }   }    return total / m; } mean(x) mean2_cpp(x)  mean(x, na.rm = TRUE) mean2_cpp(x, na_rm = TRUE)  mark(   mean(x, na.rm = TRUE),   mean2_cpp(x, na_rm = TRUE) )"},{"path":"./articles/10-statistical-functions-2.html","id":"variance","dir":"Articles","previous_headings":"","what":"Variance","title":"10 - Statistical Functions with Missing Values","text":"following function expands previous var_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double var2_cpp(doubles x, bool na_rm = false) {   int n = x.size();   int m = 0;   double total = 0, sq_total = 0;    for (int i = 0; i < n; ++i) {     if (na_rm && ISNAN(x[i])) {       continue;     } else {       ++m;       total += x[i];       sq_total += pow(x[i], 2);     }   }    if (m <= 1) {     return NA_REAL;   }    return (sq_total - total * total / m) / (m - 1); } var(x) var2_cpp(x)  var(x, na.rm = TRUE) var2_cpp(x, na_rm = TRUE)  mark(   var(x, na.rm = TRUE),   var2_cpp(x, na_rm = TRUE) )"},{"path":"./articles/10-statistical-functions-2.html","id":"root-mean-square-error-rmse","dir":"Articles","previous_headings":"","what":"Root Mean Square Error (RMSE)","title":"10 - Statistical Functions with Missing Values","text":"following function expands previous rmse_cpp() function handle missing values. test functions, can run following benchmark code R console:","code":"[[cpp4r::register]] double rmse2_cpp(doubles x, double x0, bool na_rm = false) {   int n = x.size();   int m = 0;   double total = 0;    for (int i = 0; i < n; ++i) {     if (na_rm && ISNAN(x[i])) {       continue;     } else {       ++m;       total += pow(x[i] - x0, 2);     }   }    if (m == 0) {     return NA_REAL;   }    return sqrt(total / m); } # create a list with 100 normal distributions with mean 0 and 1,000 elements each set.seed(123) x <- list() for (i in 1:1e3) {   x[[i]] <- rnorm(1e3) }  # compute the mean of each distribution x <- sapply(x, mean)  # insert NA values at random x[sample(1:1e3, 1e2)] <- NA  rmse2_cpp(x, 0) rmse2_cpp(x, 0, na_rm = TRUE)  mark(   sqrt(mean((x - 0)^2, na.rm = TRUE)),   rmse2_cpp(x, 0, na_rm = TRUE) )"},{"path":[]},{"path":"./articles/11-debugging.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"11 - Debugging R Packages","text":"previous package skeleton left essential details, testing memory leaks debugging. vignette cover aspects detail. references vignette (vaughan?), (padgham?), (vaughan2?), (wickham?), (rpkgdevel?).","code":""},{"path":"./articles/11-debugging.html","id":"compiler-setup","dir":"Articles","previous_headings":"","what":"Compiler Setup","title":"11 - Debugging R Packages","text":"test functions lead memory errors, can create/edit src/Makevars.file within package folder add: Windows, file src/Makevars.win content . requires explanations: -Wall: Enables warnings. -O0: Disables optimizations debugging purposes. Otherwise, compiler adjust package compiled binaries speedups, making harder debug. code working, can switch -O2 -O3 enable optimizations production. plan submit package CRAN, remove flag, accept . -pedantic: Enforces strict ISO C++ compliance. warn improper writing, similar bad grammar spelling errors English. -UDEBUG -g: Disables DEBUG macro enables debugging information. package ready, -g can removed reduce size compiled binaries. case “pedantic” part clear, example: Even code compiles, gives warning: possible verify functions correct:","code":"PKG_CXXFLAGS = -Wall -O0 -pedantic PKG_CPPFLAGS = -UDEBUG -g #include \"cpp4r.hpp\" #include <numeric>  using namespace cpp4r;  // Non-ISO: Use a variable length array [[cpp4r::register]] double squared_sum_non_iso_(integers inp) {   int size = inp.size();   double array[size];  // will give a warning, but still compile    for (int i = 0; i < size; ++i) {     array[i] = inp[i] * inp[i];   }    return std::accumulate(array, array + size, 0.0); }  // ISO: Use a vector [[cpp4r::register]] double squared_sum_iso_(integers inp) {   int size = inp.size();   std::vector<double> vec(size);    for (int i = 0; i < size; ++i) {     vec[i] = inp[i] * inp[i];   }    return std::accumulate(vec.begin(), vec.end(), 0.0); } code.cpp:489:10: warning: ISO C++ forbids variable length array ‘array’ [-Wvla]   489 |   double array[size];  // will give a warning, but still compile all.equal(sum((1:5)^2), squared_sum_non_iso_(1:5), squared_sum_iso_(1:5))"},{"path":"./articles/11-debugging.html","id":"testing-for-memory-leaks","dir":"Articles","previous_headings":"","what":"Testing for Memory Leaks","title":"11 - Debugging R Packages","text":"test memory leaks, can use valgrind tool. tool available Linux macOS. can test memory leaks running following command terminal: , alternatively, call R vanilla mode: test.R containing:","code":"valgrind --leak-check=full Rscript -e \"library(cpp4rexamples); squared_sum_iso_(1:5)\" R --vanilla -d 'valgrind -s --track-origins=yes' -f test.R library(cpp4rexamples) squared_sum_iso_(1:5)"},{"path":"./articles/11-debugging.html","id":"adding-a-configure-script","dir":"Articles","previous_headings":"","what":"Adding a configure script","title":"11 - Debugging R Packages","text":"portable package, recommended add configure script. script check necessary tools build package. script written bash placed configure file package root directory. example configure script cpp4rexamples package: file, meant Unix systems, must accompanied configure.win file Windows systems. Besides configure script, src/Makevars.file must created. file template src/Makevars file. example: Makevars.also Unix systems, must accompanied empty Makevars.win Windows systems. Finally, cleanup script helps get tidy package build. example: advantage approach create src/Makevars file correct flags system. way, package portable easier test GitHub Actions Docker.","code":"#!/bin/sh  PKG_CONFIG_NAME=\"gccsanissue\"  pkg-config --version >/dev/null 2>&1 if [ $? -eq 0 ]; then   PKGCONFIG_CFLAGS=`pkg-config --cflags --silence-errors`   PKGCONFIG_LIBS=`pkg-config --libs` fi  if [ \"$PKGCONFIG_CFLAGS\" ] || [ \"$PKGCONFIG_LIBS\" ]; then   echo \"Found pkg-config cflags and libs!\"   PKG_CFLAGS=${PKGCONFIG_CFLAGS}   PKG_LIBS=${PKGCONFIG_LIBS} fi  CXXFLAGS=\"-stdlib=libc++\" # CXXFLAGS=\"-O0 -g -stdlib=libc++\"  LDFLAGS=\"-stdlib=libc++\"  sed -e \"s|@cxxflags@|$CXXFLAGS|\" \\     -e \"s|@ldflags@|$LDFLAGS|\" \\     src/Makevars.in > src/Makevars  exit 0 LDFLAGS=@ldflags@  # Convert source files to object files SOURCES = code.cpp \\                     cpp4r.cpp OBJECTS = $(SOURCES:.cpp=.o)  all: $(SHLIB)  $(SHLIB): $(OBJECTS)  clean: rm -f $(OBJECTS) $(SHLIB) #!/bin/sh rm -f src/Makevars configure.log"},{"path":"./articles/11-debugging.html","id":"testing-with-docker","dir":"Articles","previous_headings":"","what":"Testing with Docker","title":"11 - Debugging R Packages","text":"CRAN checks packages different Unix platforms, additional tests compiled code include testing memory leaks valgrind address sanitizer. Derived recommendations made Dr. Krylov Dr. Eddelbuettel R-pkg-devel mailing list, can create following script test package Docker container: can add following function cpp4rexamples: access function R session, can add following R code: function bad_ introduces undefined behavior reading misaligned pointer. common issue C++ code, good example test address sanitizer. reinterpret_cast<long*> creates misaligned pointer since ptr aligned int, long. pointer dereference *misaligned_ptr introduces undefined behavior. Without sanitizers, silently execute, returns value x. sanitizers, throw error. testing valgrind container command bash dev/test-docker.sh, R checks pass, valgrind check fail following error:","code":"#!/bin/sh  PACKAGE_DIR=$(pwd)  # DOCKER_IMAGE=\"ghcr.io/r-hub/containers/valgrind:latest\" DOCKER_IMAGE=\"ghcr.io/r-hub/containers/clang-asan:latest\"  docker pull $DOCKER_IMAGE  docker run --rm -v \"$PACKAGE_DIR\":/workspace -w /workspace $DOCKER_IMAGE bash -c \"   Rscript -e 'install.packages(\\\"cpp4r\\\", repos=\\\"https://cran.rstudio.com/\\\")'   R CMD build .   R CMD check --as-cran --no-manual gccsanissue_0.1.0.tar.gz \" [[cpp4r::register]] int bad_() {   int x = 42;    // valid integer   int *ptr = &x; // pointer to `x`    // undefined behavior (alignment issue)   auto misaligned_ptr = reinterpret_cast<long*>(ptr);   return *misaligned_ptr; // Read through misaligned pointer } #' @title Bad function #' @description This function has a GCC SAN issue #' @export  #' @examples  #' bad() bad <- function() {   bad_() } Shadow bytes around the buggy address:   0x6ffdc4008d80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07    Heap left redzone:       fa   Freed heap region:       fd   Stack left redzone:      f1   Stack mid redzone:       f2   Stack right redzone:     f3   Stack after return:      f5   Stack use after scope:   f8   Global redzone:          f9   Global init order:       f6   Poisoned by user:        f7   Container overflow:      fc   Array cookie:            ac   Intra object redzone:    bb   ASan internal:           fe   Left alloca redzone:     ca   Right alloca redzone:    cb ==1244==ABORTING"},{"path":[]},{"path":[]},{"path":"./articles/13-compiler-optimization.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"13 - Compiler Optimizations","text":"R uses default GCC/Clang compiler optimizations, can limit performance C++ code.","code":""},{"path":"./articles/13-compiler-optimization.html","id":"user-wide-makevars","dir":"Articles","previous_headings":"","what":"User-wide Makevars","title":"13 - Compiler Optimizations","text":"can use following Makevars example, placed ~/.R/Makevars, set optimization level -O3 C++ code compiled R use additional flags enable aggressive optimizations can set setup level package level (CRAN reject package):","code":"# Override R's optimization level CXXFLAGS = -g -O3 -march=native CXX11FLAGS = -g -O3 -march=native CXX14FLAGS = -g -O3 -march=native CXX17FLAGS = -g -O3 -march=native  # Additional optimizations CXXFLAGS += -funroll-loops -ftree-vectorize -fprefetch-loop-arrays CXXFLAGS += -fomit-frame-pointer -fstrict-aliasing  # Link-time optimization CXXFLAGS += -flto=auto LDFLAGS += -flto=auto"},{"path":"./articles/13-compiler-optimization.html","id":"anticonf-scripts","dir":"Articles","previous_headings":"","what":"Anticonf scripts","title":"13 - Compiler Optimizations","text":"idea “anticonf” configure script provide tailored Makevars file understanding package run different systems. anticonf name comes fact standard configure script created tools GNU Autoconf, rather templated script generates Makevars detecting system compiler settings (e.g., number cores, optimization flags, etc.). capybara package following Makevars.file: file serves template Makevars file. configure script, runs package installed, replaces @ncores@ @SAFE_OPTFLAGS@ placeholders. Capybara package uses following configure script: script detects number cores available system sets CAPYBARA_NCORES variable accordingly. also tests safe optimization flags can added Makevars file without changing default -O2 optimization level used R. also serves goal testing simple file can compiled.","code":"CXX_STD ?= CXX11 CXX14 CXX17 PKG_CXXFLAGS = -DARMA_NO_DEBUG -DARMA_USE_BLAS -DARMA_USE_LAPACK -DCAPYBARA_NCORES=@ncores@ $(SHLIB_OPENMP_CXXFLAGS) @SAFE_OPTFLAGS@ PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS) $(LAPACK_LIBS) $(BLAS_LIBS) $(FLIBS) # Anticonf script by Pacha (2025)  PKG_CONFIG_NAME=\"capybara\"  # Get R configuration CXX=$(${R_HOME}/bin/R CMD config CXX) CXXFLAGS=$(${R_HOME}/bin/R CMD config CXXFLAGS)  # Function to test compiler flag test_flag() {   echo 'int main(){return 0;}' > conftest.cpp   if $CXX $CXXFLAGS $1 conftest.cpp -o conftest >/dev/null 2>&1; then     rm -f conftest conftest.cpp     return 0   else     rm -f conftest conftest.cpp     return 1   fi }  # For CRAN, we cannot override -O2, but we can add other safe optimizations SAFE_OPTFLAGS=\"\"  # Test portable optimization flags that do not change the -O level PORTABLE_OPTS=\"-funroll-loops -ftree-vectorize\" for opt in $PORTABLE_OPTS; do   if test_flag \"$opt\"; then     SAFE_OPTFLAGS=\"$SAFE_OPTFLAGS $opt\"   fi done  if [ -n \"$SAFE_OPTFLAGS\" ]; then   echo \"Additional optimizations:$SAFE_OPTFLAGS\" fi  # Detect number of cores if [ -n \"$CAPYBARA_NCORES\" ]; then   num_cores=\"$CAPYBARA_NCORES\" else   if [ -f /proc/cpuinfo ]; then     num_cores=$(grep -c \"^processor\" /proc/cpuinfo 2>/dev/null || echo 1)   elif [ \"$(uname)\" = \"Darwin\" ]; then     num_cores=$(sysctl -n hw.ncpu 2>/dev/null || echo 1)   else     num_cores=1   fi      if [ \"$num_cores\" -gt 2 ]; then     num_cores=$((num_cores - 1))   fi fi  echo \"Default thread count: $num_cores\"  # Create Makevars from template echo \"Creating src/Makevars\" sed -e \"s|@ncores@|${num_cores}|g\" \\     -e \"s|@SAFE_OPTFLAGS@|${SAFE_OPTFLAGS}|g\" \\     src/Makevars.in > src/Makevars  echo \"Configuration complete\" echo \"\" echo \"NOTE: This build will use the default -O2 optimization level for CRAN compliance.\" echo \"For maximum performance, see inst/Makevars.user.example\"  exit 0"},{"path":[]},{"path":"./articles/14-linear-algebra.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"14 - Linear Algebra","text":"R provides --box support matrices vectors. case C++ code, need use library Armadillo wrapper R (cpp11armadillo?). One nicest Armadillo features similar syntax MATLAB.","code":""},{"path":"./articles/14-linear-algebra.html","id":"using-armadillo","dir":"Articles","previous_headings":"","what":"Using Armadillo","title":"14 - Linear Algebra","text":"cpp11armadillo provides detailed R-specific documentation worked examples. examples cpp11armadillo self-contained detailed explanations, vignette repeat . one five-hundred examples cpp11armadillo package compute β̂=(XTX)−1XTy\\hat{\\beta} = (X^TX)^{-1}X^Ty linear model using cpp4r concepts already covered: One advantages cpp11armadillo connects cpp11 (cpp4r) Armadillo, allowing use as_Mat() as_doubles_matrix() functions “bread” sandwich, pure Armadillo code serves “meat”.","code":"Mat<double> ols_(const doubles_matrix<>& y, const doubles_matrix<>& x) {   Mat<double> Y = as_Mat(y);  // Col<double> Y = as_Col(y); also works   Mat<double> X = as_Mat(x);    Mat<double> XtX = X.t() * X;             // X'X   Mat<double> XtX_inv = inv(XtX);          // (X'X)^(-1)   Mat<double> beta = XtX_inv * X.t() * Y;  // (X'X)^(-1)(X'Y)    return beta; }  [[cpp4r::register]] doubles_matrix<> ols_mat_(const doubles_matrix<>& y,                                               const doubles_matrix<>& x) {   Mat<double> beta = ols_(y, x);   return as_doubles_matrix(beta); }  [[cpp4r::register]] doubles ols_dbl_(const doubles_matrix<>& y,                                      const doubles_matrix<>& x) {   Mat<double> beta = ols_(y, x);   return as_doubles(beta); }"},{"path":[]},{"path":"./articles/15-internals.html","id":"initial-setup-and-dev-workflow","dir":"Articles","previous_headings":"","what":"Initial setup and dev workflow","title":"15 - Internals","text":"development repository cpp4r https://github.com/pachadotdev/cpp4r. First install dependencies needed development. can load package interactive R session run cpp4r tests extensive tests cpp4rtest directory. Generally developing C++ headers, can run R working directory cpp4rtest directory use devtools::test() run cpp4rtests. change cpp4r headers, need install new version cpp4r clean recompile cpp4rtest package: calculate code coverage cpp4r package run following cpp4r root directory.","code":"install.packages(\"remotes\") remotes::install_deps(dependencies = TRUE) devtools::load_all() devtools::test() # Assuming that your working directory is `cpp4rtest/` devtools::clean_dll() devtools::load_all() covr::report(cpp4r_coverage())"},{"path":"./articles/15-internals.html","id":"code-formatting","dir":"Articles","previous_headings":"","what":"Code formatting","title":"15 - Internals","text":"project uses clang-format (version 18) automatically format C++ code. can run make format re-format code project. system clang-format version 18, can install https://github.com/pachadotdev/clang-format. Alternatively many IDEs support automatically running clang-format every time files written.","code":""},{"path":"./articles/15-internals.html","id":"code-organization","dir":"Articles","previous_headings":"","what":"Code organization","title":"15 - Internals","text":"cpp4r header library, source code exposed users lives inst/include. R code used register functions cpp4r::cpp_source() R/. Tests code R/ tests/testthat/. rest code separate cpp4rtest/ package included source tree. Inside cpp4rtest/src files start test- C++ tests using Catch support testthat. addition regular R tests cpp4rtest/tests/testthat/.","code":""},{"path":"./articles/15-internals.html","id":"naming-conventions","dir":"Articles","previous_headings":"","what":"Naming conventions","title":"15 - Internals","text":"header files named .hpp extension. source files named .cpp extension. Public header files put inst/include/cpp4r Read r_vector classes free functions put cpp4r namespace. Writable r_vector class put cpp4r::writable namespace. Private classes functions put cpp4r::internal namespace.","code":""},{"path":"./articles/15-internals.html","id":"vector-classes","dir":"Articles","previous_headings":"","what":"Vector classes","title":"15 - Internals","text":"basic r_vector classes class templates, base template defined cpp4r/r_vector.hpp. template parameter type value particular R vector stores, e.g. double cpp4r::doubles. differs Rcpp, whose first template parameter R vector type, e.g. REALSXP. file first class declarations, function definitions file. Specializations various types separate files, e.g. cpp4r/doubles.hpp, cpp4r/integers.hpp","code":""},{"path":"./articles/15-internals.html","id":"coercion-functions","dir":"Articles","previous_headings":"","what":"Coercion functions","title":"15 - Internals","text":"two different coercion functions as_sexp() takes C++ object coerces SEXP object, can used R. as_cpp<>() template function takes SEXP creates C++ object various methods functions defined cpp4r/.hpp definitely complex part cpp4r code, extensive use template metaprogramming. particular substitution failure error (SFINAE) technique used control overloading functions. use C++20, lot code made simpler Concepts, alas. common C++ types included test suite work without issues, exotic types used real projects additional issues may arise. useful links SFINAE https://www.fluentcpp.com/2018/05/15/make-sfinae-pretty-1--value-sfinae-brings--code/, https://www.fluentcpp.com/2018/05/18/make-sfinae-pretty-2-hidden-beauty-sfinae/","code":""},{"path":[]},{"path":"./articles/15-internals.html","id":"protect-list","dir":"Articles","previous_headings":"Protection","what":"Protect list","title":"15 - Internals","text":"cpp4r uses idea proposed Luke Tierney use double linked list head preserved protect objects cpp4r protecting. node list uses head (CAR) part point previous node, CDR part point next node. TAG used point object protected. head tail list R_NilValue CAR CDR pointers respectively. Calling cpp4r::detail::store::insert() regular R object add new node list return protect token corresponding node added. Calling cpp4r::detail::store::release() returned token release protection unlinking node linked list. two functions considered internal cpp4r, use packages. scheme scales O(1) time release insert object vs O(N) worse time R_PreserveObject() / R_ReleaseObject(). package unique protection list, avoids need manage “global” protection list shared across packages. previous version cpp4r used global protection list stored R global option, caused multiple issues. functions defined protect.hpp.","code":""},{"path":"./articles/15-internals.html","id":"unwind-protect","dir":"Articles","previous_headings":"Protection","what":"Unwind Protect","title":"15 - Internals","text":"cpp4r uses R_UnwindProtect() protect () calls R API fail. usually allocate memory, though truth R API functions error along paths. error happens R_UnwindProtect(), cpp4r throw C++ exception. exception caught try/catch block defined BEGIN_CPP4R macro cpp4r/declarations.hpp. exception cause C++ destructors run, freeing resources held C++ objects. try/catch block exits, R error unwinding continued R_ContinueUnwind() normal R error results. R >=3.5 required use cpp4r, created, goal support back R 3.3, R_ContinueUnwind() available R 3.5. options considered support older R versions: Using R_TopLevelExec() works avoid C long jump, code always run top level context errors messages thrown caught tryCatch() similar techniques. Using R_TryCatch() available prior R 3.4, also serious bug R 3.4 (fixed R 3.5). Calling R level tryCatch() function contains expression runs C function runs C++ code option, implementing convoluted impact performance, perhaps severely. cpp4r::unwind_protect() -op versions. means resources held C++ objects leak, including cpp4r::r_vector / cpp4r::sexp objects. None options perfect. pros cons : Causes behavior changes test failures, ruled . also ruled since wanted support back R 3.3. ruled partially implementation somewhat tricky performance suffer greatly. ended done requiring R 3.5. leaked protected objects R API errors.","code":""},{"path":[]},{"path":"./articles/16-FAQ.html","id":"how-do-i-add-elements-to-a-list","dir":"Articles","previous_headings":"","what":"2. How do I add elements to a list?","title":"17 - FAQs","text":"Use push_back() method. need use cpp4r::as_sexp() want convert arbitrary C++ objects SEXP inserting list. create named lists, use push_back() method named literal syntax. named literal syntax defined cpp4r::literals namespace. case, creating named literal automatically calls as_sexp() . Note know size list ahead time (often !), efficient state front.","code":"#include <cpp4r.hpp> #include <vector>  [[cpp4r::register]] cpp4r::writable::list foo_push() {   cpp4r::writable::list x;    // An object that is already a `SEXP`   x.push_back(R_NilValue);    // A single integer   x.push_back(cpp4r::as_sexp(1));    // A C++ vector of ints   std::vector<int> elt{1, 2, 3};   x.push_back(cpp4r::as_sexp(elt));    return x; } #include <cpp4r.hpp>  [[cpp4r::register]] cpp4r::writable::list foo_push_named() {   using namespace cpp4r::literals;    cpp4r::writable::list x;   x.push_back({\"foo\"_nm = 1});    return x; } #include <cpp4r.hpp> #include <vector>  [[cpp4r::register]] cpp4r::writable::list foo_push_sized() {   std::vector<int> elt{1, 2, 3};    R_xlen_t size = 3;    cpp4r::writable::list x(size);   x[0] = R_NilValue;   x[1] = cpp4r::as_sexp(1);   x[2] = cpp4r::as_sexp(elt);    return x; }"},{"path":"./articles/16-FAQ.html","id":"does-cpp4r-support-default-arguments","dir":"Articles","previous_headings":"","what":"3. Does cpp4r support default arguments?","title":"17 - FAQs","text":"cpp4r support default arguments, convenient require complexity support currently worthwhile. need default argument support can use wrapper function around cpp4r registered function. common convention name internal function trailing _.","code":"#include <cpp4r.hpp> [[cpp4r::register]] double add_some_(double x, double amount) {   return x + amount; } add_some <- function(x, amount = 1) {   add_some_(x, amount) } add_some(1) add_some(1, amount = 5)"},{"path":"./articles/16-FAQ.html","id":"how-do-i-create-a-new-empty-list","dir":"Articles","previous_headings":"","what":"4. How do I create a new empty list?","title":"17 - FAQs","text":"Define new writable list object. cpp4r::writable::list x;","code":""},{"path":"./articles/16-FAQ.html","id":"how-do-i-retrieve-named-elements-from-a-named-vectorlist","dir":"Articles","previous_headings":"","what":"5. How do I retrieve (named) elements from a named vector/list?","title":"17 - FAQs","text":"Use [] accessor function. x[\"foo\"]","code":""},{"path":"./articles/16-FAQ.html","id":"how-can-i-tell-whether-a-vector-is-named","dir":"Articles","previous_headings":"","what":"6. How can I tell whether a vector is named?","title":"17 - FAQs","text":"Use named() method vector classes.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] bool is_named(cpp4r::strings x) {   return x.named(); } is_named(\"foo\")  is_named(c(x = \"foo\"))"},{"path":"./articles/16-FAQ.html","id":"how-do-i-return-a-cpp4rwritablelogicals-object-with-only-a-false-value","dir":"Articles","previous_headings":"","what":"7. How do I return a cpp4r::writable::logicals object with only a FALSE value?","title":"17 - FAQs","text":"need use list initialization {} create object.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] cpp4r::writable::logicals my_false() {   return {FALSE}; }  [[cpp4r::register]] cpp4r::writable::logicals my_true() {   return {TRUE}; }  [[cpp4r::register]] cpp4r::writable::logicals my_both() {   return {TRUE, FALSE, TRUE}; } my_false()  my_true()  my_both()"},{"path":"./articles/16-FAQ.html","id":"how-do-i-create-a-new-empty-environment","dir":"Articles","previous_headings":"","what":"8. How do I create a new empty environment?","title":"17 - FAQs","text":"need call base::new.env() function C++. can done creating cpp4r::function object calling generate new environment.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] cpp4r::environment create_environment() {   cpp4r::function new_env(cpp4r::package(\"base\")[\"new.env\"]);   return new_env(); }"},{"path":"./articles/16-FAQ.html","id":"how-do-i-assign-and-retrieve-values-in-an-environment-what-happens-if-i-try-to-get-a-value-that-does-not-exist","dir":"Articles","previous_headings":"","what":"9. How do I assign and retrieve values in an environment? What happens if I try to get a value that does not exist?","title":"17 - FAQs","text":"Use [] retrieve assign values environment name. value exist, error. check existence ahead time, use exists() method.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] bool foo_exists(cpp4r::environment x) {   return x.exists(\"foo\"); }  [[cpp4r::register]] void set_foo(cpp4r::environment x, double value) {   x[\"foo\"] = value; } x <- new.env()  foo_exists(x)  set_foo(x, 1)  foo_exists(x)"},{"path":"./articles/16-FAQ.html","id":"how-can-i-create-a-cpp4rraws-from-a-stdstring","dir":"Articles","previous_headings":"","what":"10. How can I create a cpp4r:raws from a std::string?","title":"17 - FAQs","text":"built way . One method push_back() element string individually.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] cpp4r::raws push_raws() {   std::string x(\"hi\");   cpp4r::writable::raws out;    for (auto c : x) {     out.push_back(c);   }    return out; } push_raws()"},{"path":"./articles/16-FAQ.html","id":"how-can-i-create-a-stdstring-from-a-cpp4rwritablestring","dir":"Articles","previous_headings":"","what":"11. How can I create a std::string from a cpp4r::writable::string?","title":"17 - FAQs","text":"C++ allow two implicit cast, explicitly cast cpp4r::r_string first.","code":"#include <cpp4r.hpp> #include <string>  [[cpp4r::register]] std::string my_string() {   cpp4r::writable::strings x({\"foo\", \"bar\"});   std::string elt = cpp4r::r_string(x[0]);   return elt; }"},{"path":"./articles/16-FAQ.html","id":"what-are-the-types-for-c-iterators","dir":"Articles","previous_headings":"","what":"12. What are the types for C++ iterators?","title":"17 - FAQs","text":"iterators ::iterator classes contained inside vector classes. example iterator cpp4r::doubles cpp4r::doubles::iterator iterator cpp4r::writable::doubles cpp4r::writable::doubles::iterator.","code":""},{"path":"./articles/16-FAQ.html","id":"my-code-has-using-namespace-std-why-do-i-still-have-to-include-std-in-the-signatures-of-cpp4rregister-functions","dir":"Articles","previous_headings":"","what":"13. My code has using namespace std, why do I still have to include std:: in the signatures of [[cpp4r::register]] functions?","title":"17 - FAQs","text":"using namespace std directive included generated code function signatures, still need fully qualified. However need qualify type names within functions. following compile compile work intended","code":"#include <cpp4r.hpp> #include <string>  using namespace std;  [[cpp4r::register]] string foobar() {   return string(\"foo\") + \"-bar\"; } #include <cpp4r.hpp> #include <string>  using namespace std;  [[cpp4r::register]] std::string foobar() {   return string(\"foo\") + \"-bar\"; }"},{"path":"./articles/16-FAQ.html","id":"how-do-i-modify-a-vector-in-place","dir":"Articles","previous_headings":"","what":"14. How do I modify a vector in place?","title":"17 - FAQs","text":"place modification breaks normal semantics R code. general avoided, cpp4r::writable classes always copy data constructed. However, positive -place modification necessary use case, can use move constructor .","code":"#include <cpp4r.hpp>  [[cpp4r::register]] void add_one(cpp4r::sexp x_sexp) {   cpp4r::writable::integers x(std::move(x_sexp.data()));   for (auto&& value : x) {     ++value;   } } x <- c(1L, 2L, 3L, 4L) .Internal(inspect(x)) add_one(x) .Internal(inspect(x)) x"},{"path":"./articles/16-FAQ.html","id":"should-i-call-cpp4runwind_protect-manually","dir":"Articles","previous_headings":"","what":"15. Should I call cpp4r::unwind_protect() manually?","title":"17 - FAQs","text":"cpp4r::unwind_protect() cpp4r’s way safely calling R’s C API. short, allows run function might throw R error, catch longjmp() error, promote exception thrown caught try/catch cpp4r sets .Call() time (allows destructors run), finally tells R continue unwinding stack now C++ objects chance destruct needed. Since cpp4r::unwind_protect() takes arbitrary function, may wondering use custom needs. general, advised extremely advanced feature prone subtle hard debug issues.","code":""},{"path":"./articles/16-FAQ.html","id":"destructors","dir":"Articles","previous_headings":"15. Should I call cpp4r::unwind_protect() manually?","what":"Destructors","title":"17 - FAQs","text":"following setup test_destructor_ok() manual call unwind_protect() work: happen move unwind_protect(), destructed, end memory leak best, much sinister issue destructor important: general, code can called within unwind_protect() “pure” C code C++ code uses POD (plain-old-data) types exceptions. mix complex C++ objects R’s C API within unwind_protect(), R errors result jump prevents destructors running.","code":"#include <cpp4r.hpp>  class A {  public:   ~A(); };  A::~A() {   Rprintf(\"hi from the destructor!\"); }  [[cpp4r::register]] void test_destructor_ok() {   A a{};   cpp4r::unwind_protect([&] {     Rf_error(\"oh no!\");   }); }  [[cpp4r::register]] void test_destructor_bad() {   cpp4r::unwind_protect([&] {     A a{};     Rf_error(\"oh no!\");   }); } test_destructor_ok() test_destructor_bad() #> Error: oh no!"},{"path":"./articles/16-FAQ.html","id":"nested-unwind_protect","dir":"Articles","previous_headings":"15. Should I call cpp4r::unwind_protect() manually?","what":"Nested unwind_protect()","title":"17 - FAQs","text":"Another issue can arise nested calls unwind_protect(). hard (impossible) end invalidly nested unwind_protect() calls using typical cpp4r API, can manually create scenario like following: run test_nested() R, likely crash hang R session due following chain events: test_nested() sets try/catch catch unwind exceptions outer unwind_protect() called. uses C function R_UnwindProtect() call lambda function. inner unwind_protect() called. uses R_UnwindProtect(), time call Rf_error(). Rf_error() performs longjmp() caught inner unwind_protect() promoted exception. exception thrown, code outer call R_UnwindProtect() (C function), ends throwing exception across C stack frames. undefined behavior, known caused R crash certain platforms. might think ’d never , scenario can also occur combination 1 call unwind_protect() combined usage cpp4r API: cpp4r::stop() (cpp4r API) uses unwind_protect() internally, indirectly ended nested unwind_protect() scenario . general, must use unwind_protect() must careful use cpp4r API inside unwind_protect() call. worth pointing calling R function cpp4r calls back cpp4r still safe, .e. registered version imaginary test_outer() function called R, work: might seem unsafe cpp4r::package() uses unwind_protect() call R function test_inner(), goes back C++ call cpp4r::stop(), uses unwind_protect(), seems like code nested scenario, scenario actually work. makes sense analyze one step time: Call R function test_outer() try/catch set catch unwind exceptions C++ function test_outer() called cpp4r::package() uses unwind_protect() call R function test_inner() Call R function test_inner() try/catch set catch unwind exceptions (key!) C++ function test_inner() called cpp4r::stop(\"oh !\") called, uses unwind_protect() call Rf_error(), causing longjmp(), caught unwind_protect() promoted exception. exception thrown, time caught try/catch set test_inner() entered R side. prevents exception crossing C++ -> C boundary. try/catch calls R_ContinueUnwind(), longjmp()s , now unwind_protect() set cpp4r::package() catches , promotes exception. exception thrown caught try/catch set test_outer(). try/catch calls R_ContinueUnwind(), longjmp()s , point longjmp() can safely proceed force R error.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] void test_nested() {   cpp4r::unwind_protect([&] {     cpp4r::unwind_protect([&] {       Rf_error(\"oh no!\");     });   }); } #include <cpp4r.hpp>  [[cpp4r::register]] void test_hidden_nested() {   cpp4r::unwind_protect([&] {     cpp4r::stop(\"oh no!\");   }); } #include <cpp4r.hpp>  [[cpp4r::register]] void test_inner() {   cpp4r::stop(\"oh no!\") }  [[cpp4r::register]] void test_outer() {   auto fn = cpp4r::package(\"mypackage\")[\"test_inner\"]   fn(); }"},{"path":"./articles/16-FAQ.html","id":"ok-but-i-really-want-to-call-cpp4runwind_protect-manually","dir":"Articles","previous_headings":"","what":"16. Ok but I really want to call cpp4r::unwind_protect() manually","title":"17 - FAQs","text":"read bullet still feel like need call unwind_protect(), keep mind following writing function unwind-protect: create C++ objects destructors. use parts cpp4r API may call unwind_protect(). must careful call unwind_protect() nested manner. words, use plain-old-data types, careful never throw exceptions, use R’s C API, can use unwind_protect(). One place may want working long character vectors. Unfortunately, due way cpp4r must protect individual CHARSXP objects make character vector, can currently quite slow use cpp4r API . Consider example extracting individual elements x[] vs using native R API: plans improve future, now one places felt reasonable call unwind_protect() manually.","code":"#include <cpp4r.hpp>  [[cpp4r::register]] cpp4r::sexp test_extract_cpp4r(cpp4r::strings x) {   const R_xlen_t size = x.size();    for (R_xlen_t i = 0; i < size; ++i) {     (void) x[i];   }    return R_NilValue; }  [[cpp4r::register]] cpp4r::sexp test_extract_r_api(cpp4r::strings x) {   const R_xlen_t size = x.size();   const SEXP data{x};    cpp4r::unwind_protect([&] {     for (R_xlen_t i = 0; i < size; ++i) {       (void) STRING_ELT(data, i);     }   });    return R_NilValue; } set.seed(123) x <- sample(letters, 1e6, replace = TRUE)  bench::mark(   test_extract_cpp4r(x),   test_extract_r_api(x) )"},{"path":"./articles/16-FAQ.html","id":"how-do-i-modify-a-matrix-rownamescolnames-on-c-side","dir":"Articles","previous_headings":"","what":"17. How do I modify a matrix rownames/colnames on C++ side?","title":"17 - FAQs","text":"following options work (commented code works cpp4r):","code":"[[cpp4r::register]] cpp4r::doubles_matrix<> copy_mat(cpp4r::doubles_matrix<> x) {   cpp4r::writable::doubles_matrix<> out = x;    // SEXP dimnames = x.attr(\"dimnames\");   // if (dimnames != R_NilValue) {   //   Rf_setAttrib(out.data(), R_DimNamesSymbol, dimnames);   // }    out.attr(\"dimnames\") = x.attr(\"dimnames\");    return out; }  [[cpp4r::register]] SEXP copy_mat_as_sexp(cpp4r::doubles_matrix<> x) {   cpp4r::writable::doubles_matrix<> out = x;    // SEXP dimnames = x.attr(\"dimnames\");   // if (dimnames != R_NilValue) {   //   Rf_setAttrib(out.data(), R_DimNamesSymbol, dimnames);   // }    out.attr(\"dimnames\") = x.attr(\"dimnames\");    return out; }  [[cpp4r::register]] cpp4r::doubles_matrix<> create_mat() {   cpp4r::writable::doubles_matrix<> out(2, 2);    out(0, 0) = 1;   out(0, 1) = 2;   out(1, 0) = 3;   out(1, 1) = 4;    cpp4r::writable::list dimnames(2);   dimnames[0] = cpp4r::strings({\"a\", \"b\"});   dimnames[1] = cpp4r::strings({\"c\", \"d\"});    out.attr(\"dimnames\") = dimnames;    return out; }  [[cpp4r::register]] cpp4r::doubles_matrix<> create_mat_no_rownames() {   cpp4r::writable::doubles_matrix<> out(2, 2);    out(0, 0) = 1;   out(0, 1) = 2;   out(1, 0) = 3;   out(1, 1) = 4;    cpp4r::writable::list dimnames(2);   dimnames[0] = R_NilValue; // No row names   dimnames[1] = cpp4r::strings({\"x1\", \"x2\"});    out.attr(\"dimnames\") = dimnames;    return out; }"},{"path":"./articles/17-worked-examples.html","id":"motivation","dir":"Articles","previous_headings":"","what":"Motivation","title":"16 - Worked Examples","text":"previous package skeleton left essential details, testing memory leaks debugging. vignette cover aspects detail. references vignette (vaughan?), (padgham?), (vaughan2?), (wickham?).","code":""},{"path":[]},{"path":"./articles/17-worked-examples.html","id":"solving-a-matrix-using-the-gauss-jordan-method","dir":"Articles","previous_headings":"Instructional examples","what":"Solving a matrix using the Gauss-Jordan method","title":"16 - Worked Examples","text":"example package covers following topics: Integers Doubles Matrices Conditionals Loops () Vendoring See cpp4rgaussjordan package.","code":""},{"path":"./articles/17-worked-examples.html","id":"details","dir":"Articles","previous_headings":"Instructional examples > Solving a matrix using the Gauss-Jordan method","what":"Details","title":"16 - Worked Examples","text":"implementation naive approach, can used, example, obtain Ordinary Least Squares (OLS) estimator shown next section. Vendoring means dependency code, cpp4r C++ headers, copied project’s source tree. ensures dependency code fixed stable updated. advantage vendoring changes cpp4r package never break package’s code. disadvantage fixes new features available vendoring code .","code":""},{"path":"./articles/17-worked-examples.html","id":"vendoring","dir":"Articles","previous_headings":"Instructional examples > Solving a matrix using the Gauss-Jordan method","what":"Vendoring","title":"16 - Worked Examples","text":"can start create_package(\"~/github/cpp4rgaussjordan\"). can use VSCode, steps also apply RStudio. opening ~/github/cpp4rgaussjordan, can run use_cpp4r() readily available skeleton project. can run use_apache_licence() LICENSE file indicate DESCRIPTION package distributed Apache License. can run cpp_vendor() copy C++ headers inst/include.","code":""},{"path":"./articles/17-worked-examples.html","id":"building-and-testing","dir":"Articles","previous_headings":"Instructional examples > Solving a matrix using the Gauss-Jordan method","what":"Building and testing","title":"16 - Worked Examples","text":"can use devtools build test package:","code":"# build  devtools::clean_dll() cpp4r::cpp_register() devtools::document() devtools::load_all()  # test  A <- matrix(c(2,1,3,-1), nrow = 2, ncol = 2) invert_matrix(A)  > invert_matrix(A)      [,1] [,2] [1,]  0.2  0.6 [2,]  0.2 -0.4"},{"path":"./articles/17-worked-examples.html","id":"ordinary-least-squares-ols-estimator","dir":"Articles","previous_headings":"Instructional examples","what":"Ordinary Least Squares (OLS) estimator","title":"16 - Worked Examples","text":"example package covers following topics: Integers Doubles Doubles matrices Conditionals See cpp4rols package. implementation extremely naive, quite similar Gauss-Jordan example extra steps, enough show use C++ code within R. One approach create one function per step, means creating one function obtain XtXX^tX, another (XtX)−1(X^tX)^{-1} (e.g, implementing Gauss-Jordan method invert matrix), another XtYX^tY calling functions obtain β̂=(XtX)−1(XtY)\\hat{\\beta} = (X^tX)^{-1}(X^tY). good challenge implement QR decomposition used lm() function R use obtain OLS estimator C++. (drury?) provides good starting point, trivial implement. hard beat performance lm() function R, calls compiled C FORTRAN functions, functions fast robust lm().","code":""},{"path":"./articles/17-worked-examples.html","id":"linear-programming-simplex-phase-2","dir":"Articles","previous_headings":"Instructional examples","what":"Linear programming (Simplex phase 2)","title":"16 - Worked Examples","text":"example package covers following topics: Integers Doubles Doubles matrices Conditionals Loops () Messages See cpp4rsimplex package.","code":""},{"path":"./articles/17-worked-examples.html","id":"algorithm","dir":"Articles","previous_headings":"Instructional examples > Linear programming (Simplex phase 2)","what":"Algorithm","title":"16 - Worked Examples","text":"simplex algorithm well described Introduction Linear Optimization efficient software solve , including (lpsolve?). problem written canonical form represented table : x1⋯xnc1⋯cn−za11⋯a1nb1⋮⋱⋮⋮am1⋯amnbm \\begin{array}{ccc|c} x_1 & \\cdots & x_n & \\\\ \\hline c_1 & \\cdots & c_n & -z \\\\ a_{11} & \\cdots & a_{1n} & b_1 \\\\ \\vdots & \\ddots & \\vdots & \\vdots \\\\ a_{m1} & \\cdots & a_{mn} & b_m \\end{array} c1,…,cnc_1, \\ldots, c_n coefficients objective function (.e., costs), a11,…,amna_{11}, \\ldots, a_{mn} coefficients constraints, b1,…,bmb_1, \\ldots, b_m right-hand side constraints. simplex algorithm solve problem consists next steps: cj≥0c_j \\geq 0 jj, current solution optimal. Basic variables equal bib_i non-basic variables equal 0. cj<0c_j < 0 jj, choose enter base. Choose variable negative cjc_j, assume j=sj = s. ais≤0a_{} \\leq 0 ii, problem unbounded. ais>0a_{} > 0 ii, choose =ri = r brars=min(biais,ais0)\\frac{b_r}{a_{rs}} = \\min(\\frac{b_i}{a_is},\\: a_{} 0) pivot arsa_{rs}, go back step 1. coefficients updated according : aij←aij−aisarjarsa_{ij} \\leftarrow a_{ij} - \\frac{a_{} a_{rj}}{a_{rs}} j≠sj \\neq s arj←arjarsa_{rj} \\leftarrow \\frac{a_{rj}}{a_{rs}} bi←bi−aisbrarsb_i \\leftarrow b_i - \\frac{a_{} b_r}{a_{rs}} ≠ri \\neq r br←brarsb_r \\leftarrow \\frac{b_r}{a_{rs}} cj←cj−csarjarsc_j \\leftarrow c_j - \\frac{c_s a_{rj}}{a_{rs}} −z←−z−csbrars-z \\leftarrow -z - \\frac{c_s b_r}{a_{rs}} algorithm equivalent Gauss method solve linear systems.","code":""},{"path":"./articles/17-worked-examples.html","id":"numerical-example","dir":"Articles","previous_headings":"Instructional examples > Linear programming (Simplex phase 2)","what":"Numerical example","title":"16 - Worked Examples","text":"simple example following minimization problem: min−x1−3x2subject tox1+x2≥3−3x1+x2≥2x1,x2≥0 \\begin{aligned} \\text{min} \\quad & -x_1 - 3x_2 \\\\ \\text{subject } \\quad & x_1 + x_2 \\geq 3 \\\\ & -3x_1 + x_2 \\geq 2 \\\\ & x_1, x_2 \\geq 0 \\end{aligned} canonical form, problem : min−x1−3x2+0x3+0x4subject tox1+x2+x3=3−3x1+x2+x4=2x1,x2,x3,x4≥0 \\begin{aligned} \\text{min} \\quad & -x_1 - 3x_2 + 0x_3 + 0x_4 \\\\ \\text{subject } \\quad & x_1 + x_2 + x_3 = 3 \\\\ & -3x_1 + x_2 + x_4 = 2 \\\\ & x_1, x_2,x_3,x_4 \\geq 0 \\end{aligned} initial tableau problem : x1x2x3x4−z−1−300011103−31012 \\begin{array}{cccc|c} x_1 & x_2 & x_3 & x_4 & -z \\\\ \\hline -1 & -3 & 0 & 0 & 0 \\\\ 1 & 1 & 1 & 0 & 3 \\\\ -3 & 1 & 0 & 1 & 2 \\end{array} first row cost row, last column right-hand side, rest matrix AA. first step pivot row 2 column 2: x1x2x3x4−z−100036401−11−31012 \\begin{array}{cccc|c} x_1 & x_2 & x_3 & x_4 & -z \\\\ \\hline -10 & 0 & 0 & 3 & 6 \\\\ 4 & 0 & 1 & -1 & 1 \\\\ -3 & 1 & 0 & 1 & 2 \\end{array} second step pivot row 2 column 1: x1x2x3x4−z005/21/217/2101/4−1/41/4013/41/411/4 \\begin{array}{cccc|c} x_1 & x_2 & x_3 & x_4 & -z \\\\ \\hline 0 & 0 & 5/2 & 1/2 & 17/2 \\\\ 1 & 0 & 1/4 & -1/4 & 1/4 \\\\ 0 & 1 & 3/4 & 1/4 & 11/4 \\end{array} stopping criterion reached: minimum cost non-negative, therefore solution optimal x*=(14,114,0,0)x^* = (\\frac{1}{4}, \\frac{11}{4}, 0 , 0) optimal value z*=−172z^* = -\\frac{17}{2}.","code":""},{"path":"./articles/17-worked-examples.html","id":"building-and-testing-1","dir":"Articles","previous_headings":"Instructional examples > Linear programming (Simplex phase 2)","what":"Building and testing","title":"16 - Worked Examples","text":"can use devtools build test package: result :","code":"# build  devtools::clean_dll() cpp4r::cpp_register() devtools::document() devtools::load_all()  # test  c <- c(-1, -3) b <- c(3, 2)  A <- matrix(     c(1, -3, 1, 1),     nrow = 2,     ncol = 2,     byrow = FALSE )  cpp4r_simplex_phase2(c, b, A) Initial tableau: -1 -3  0  0  0   1  1  1  0  3  -3  1  0  1  2  Minimum cost: -3 Pivot row: 2 Pivot column: 2 ==== New tableau: -10  0  0  3  6   4  0  1 -1  1  -3  1  0  1  2  Minimum cost: -10 Pivot row: 1 Pivot column: 1 ==== New tableau:  0  0  2.5  0.5  8.5   1  0  0.25 -0.25  0.25   0  1  0.75  0.25  2.75  Minimum cost: 0 Optimal solution found in 2 steps !"},{"path":"./articles/17-worked-examples.html","id":"using-omp-parallelization","dir":"Articles","previous_headings":"Instructional examples","what":"Using OMP (parallelization)","title":"16 - Worked Examples","text":"example package covers following topics: Integers Doubles Lists (unnamed named) Loops () OpenMP parallelization See cpp4romp package.","code":""},{"path":"./articles/17-worked-examples.html","id":"motivation-1","dir":"Articles","previous_headings":"Instructional examples > Using OMP (parallelization)","what":"Motivation","title":"16 - Worked Examples","text":"One common phrase might find need search something cpp4r : “cpp4r offer OpenMP support.” myth. cpp4r offer OpenMP support. requirements : processor C++ compiler support OpenMP. tested Windows, need install Rtools, Ubuntu need anything special gcc compiler comes operating system just works. using macOS, need install libomp via Homebrew order extend clang compiler, explained OpenBox documentation (openbox?).","code":""},{"path":"./articles/17-worked-examples.html","id":"enabling-openmp","dir":"Articles","previous_headings":"Instructional examples > Using OMP (parallelization)","what":"Enabling OpenMP","title":"16 - Worked Examples","text":"can create R package called cpp4romp following code: , can create file R/cpp4romp-package.R following contents: order get #pragma instruction work, need add following src/Makevars: adding means pragma instruction ignored functions run single thread.","code":"usethis::create_project(\"cpp4romp\") usethis::use_cpp4r() ## usethis namespace: start #' @useDynLib cpp4romp, .registration = TRUE ## usethis namespace: end NULL PKG_CXXFLAGS = $(SHLIB_OPENMP_CXXFLAGS) -DARMA_OPENMP_THREADS=1 PKG_LIBS = $(SHLIB_OPENMP_CXXFLAGS) CXX_STD = CXX11"},{"path":"./articles/17-worked-examples.html","id":"unnamed-list","dir":"Articles","previous_headings":"Instructional examples > Using OMP (parallelization)","what":"Unnamed list","title":"16 - Worked Examples","text":"can add function called squared_unnamed_ src/code.cpp square element vector doubles, file content corresponds following: previous function returns unnamed list two elements: squared vector thread number. function registered [[cpp4r::register]] can called R. C++ strict types, need create wrapper function convert integers doubles avoid accidental errors, go R/cpp4romp-package.R:","code":"#include <cpp4r.hpp> #include <omp.h>  using namespace cpp4r;  [[cpp4r::register]] list squared_unnamed_(doubles x) {   // create vectors y = x^2 and z = thread number   int n = x.size();   writable::doubles y(n);   writable::doubles z(n);      #pragma omp parallel for   for (int i = 0; i < n; ++i) {     y[i] = x[i] * x[i];     z[i] = omp_get_thread_num();   }    //create a list containing y and z   writable::list out;   out.push_back(y);   out.push_back(z);   return out; } #' Unnamed list with squared numbers and the threads used #' @param x A vector of doubles #' @export squared_unnamed <- function(x) {   squared_unnamed_(as.double(x)) }"},{"path":"./articles/17-worked-examples.html","id":"named-list","dir":"Articles","previous_headings":"Instructional examples > Using OMP (parallelization)","what":"Named list","title":"16 - Worked Examples","text":"can add function called squared_named_ src/code.cpp returns named list. additional content corresponds following: previous part, can add wrapper documentation:","code":"[[cpp4r::register]] list squared_named_(doubles x) {   // create vectors y = x^2 and z = thread number   int n = x.size();   writable::doubles y(n);   writable::doubles z(n);      #pragma omp parallel for   for (int i = 0; i < n; ++i) {     y[i] = x[i] * x[i];     z[i] = omp_get_thread_num();   }    //create a list containing y and z   writable::list out;   out.push_back({\"x^2\"_nm = y});   out.push_back({\"thread\"_nm = z});   return out; } #' Named list with squared numbers and the threads used #' @param x A vector of doubles #' @export squared_named <- function(x) {   squared_named_(as.double(x)) }"},{"path":"./articles/17-worked-examples.html","id":"building-and-testing-2","dir":"Articles","previous_headings":"Instructional examples > Using OMP (parallelization)","what":"Building and testing","title":"16 - Worked Examples","text":"can use devtools build test package: , can test package new R session:","code":"cpp4r::cpp_register() devtools::document() devtools::install() > library(cpp4romp) > squared_unnamed(1:10) [[1]]  [1]   1   4   9  16  25  36  49  64  81 100  [[2]]  [1] 0 0 1 1 2 3 4 5 6 7  > squared_named(1:10) $`x^2`  [1]   1   4   9  16  25  36  49  64  81 100  $thread  [1] 0 0 1 1 2 3 4 5 6 7"},{"path":"./articles/17-worked-examples.html","id":"implementing-a-rejection-and-bootstrap-sampler","dir":"Articles","previous_headings":"Instructional examples","what":"Implementing a rejection and bootstrap sampler","title":"16 - Worked Examples","text":"example package covers following topics: Integers Doubles Matrices Push back Random seed state See differences cpp11, cpp4r Rcpp: cpp11sampling package. cpp4rsampling package. Rcppsampling package.","code":""},{"path":"./articles/17-worked-examples.html","id":"extensive-rc-tests","dir":"Articles","previous_headings":"","what":"Extensive R/C++ tests","title":"16 - Worked Examples","text":"See cpp4rtest package. covers 1,000 unit tests cpp4r features, including: Vectors (integers, doubles, logicals, strings) Matrices (integers, doubles, logicals, strings) Lists (named unnamed) Data frames Error handling (stop, warning, message) C++ side unit tests testthat Roxygen documentation","code":""},{"path":"./articles/17-worked-examples.html","id":"useful-rc-integration-examples","dir":"Articles","previous_headings":"","what":"Useful R/C++ Integration Examples","title":"16 - Worked Examples","text":"examples C++ code integration R using cpp11 package: arrow: R package provides bindings Arrow C++ library. Arrow columnar -memory analytics format extremely fast efficient. cpp4rarmadillo: R package provides bindings Armadillo C++ library. Armadillo high-quality linear algebra library syntax similar MATLAB. cpp11eigen: R package provides bindings Eigen C++ library. Eigen high-performance linear algebra library permissive license. haven: package reads writes SPSS, Stata, SAS files R. kendallknight: Implements Kendall’s correlation coefficient C++, achieving speedup using algorithm complexity O(nlog(n))O(n \\log(n)) instead O(n2)O(n^2) base R. mice: package imputes missing data using multivariate chained equations. redatam: C++ implementation Redatam file format, callable R Python. RPostgres: C++ interface PostgreSQL using cpp4r. tidyr: package uses C++ functions reshape data frames.","code":""},{"path":[]},{"path":"./authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Mauricio Vargas Sepulveda. Author, maintainer. Posit Software, PBC. Author.           Original cpp11 package","code":""},{"path":"./authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Vargas Sepulveda M, Posit Software, PBC (2025). cpp4r: Header-'C++' 'R' Interface. R package version 0.3.0, https://cpp4r.org.","code":"@Manual{,   title = {cpp4r: Header-Only 'C++' and 'R' Interface},   author = {Mauricio {Vargas Sepulveda} and {Posit Software, PBC}},   year = {2025},   note = {R package version 0.3.0},   url = {https://cpp4r.org}, }"},{"path":"./index.html","id":"cpp4r-","dir":"","previous_headings":"","what":"Header-Only C++ and R Interface","title":"Header-Only C++ and R Interface","text":"cpp4r helps interact R objects using C++ code. fork cpp11 package identical syntax similar goals. ⚠️Important⚠️: cpp4r created ease writing functions packages offer --fly compilation code snippets. cpp4r can used replacement cpp11 existing new packages. Think cpp11 cpp4r MySQL MariaDB: almost identical, cpp4r extra features. discussing pull requests Hadley Wickham Posit, mentioned create fork add following features: Convert ordered unordered C++ maps R lists. Roxygen support C++ side. Allow dimnames attribute matrices C++ side. Support nullable external_ptr<>. Use values added vector push_back() immediately. Support bidirectional passing complex numbers/vectors. Provide flexibility data types (e.g., cpp4r’s as_integers() as_doubles() accept logical inputs cpp11’s ). internal optimizations better speed (e.g., https://github.com/r-lib/cpp11/pull/463 https://github.com/r-lib/cpp11/pull/430).","code":""},{"path":"./index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Header-Only C++ and R Interface","text":"Check documentation get started using cpp4r scripts, particularly new C++ programming.","code":""},{"path":"./index.html","id":"using-cpp4r-in-a-package","dir":"","previous_headings":"","what":"Using cpp4r in a package","title":"Header-Only C++ and R Interface","text":"Create new package cpp4r::pkg_template(\"~/path//mypkg\") edit generated files. add cpp4r existing package, put C++ files src/ directory add following DESCRIPTION file: add roxygen header, example, R/mypkg-package.R: decorate C++ functions want expose R [[cpp4r::register]]. cpp4r header library hard dependencies use shared library. straightforward reliable use packages without fear compile-time run-time mismatches.","code":"LinkingTo: cpp4r #' @useDynLib mypkg, .registration = TRUE #' @keywords internal \"_PACKAGE\""},{"path":"./index.html","id":"vendoring","dir":"","previous_headings":"","what":"Vendoring","title":"Header-Only C++ and R Interface","text":"can vendor current installed version cpp4r headers package cpp4r::vendor(). cpp4rvendor package shows example vendoring cpp4r headers. Vendoring ensures headers remain unchanged explicitly update . advantage package break breaking changes future versions cpp4r. disadvantage get bug fixes new features unless update vendored headers.","code":""},{"path":"./index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Header-Only C++ and R Interface","text":"Please open issue email . best respond 48 hours.","code":""},{"path":"./index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Header-Only C++ and R Interface","text":"Contributions welcome! Please see internals vignette details design choices coding style.","code":""},{"path":"./index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Header-Only C++ and R Interface","text":"Please note cpp4r project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"./reference/cpp4r-package.html","id":null,"dir":"Reference","previous_headings":"","what":"cpp4r: Header-Only 'C++' and 'R' Interface — cpp4r-package","title":"cpp4r: Header-Only 'C++' and 'R' Interface — cpp4r-package","text":"Provides header , 'C++' interface 'R' enhancements 'cpp11'. Enforces copy--write semantics consistent 'R' behavior. Offers native support ALTREP objects, 'UTF-8' string handling, modern 'C++11' features idioms, reduced memory requirements. Allows vendoring, making useful restricted environments. Compared 'cpp11', adds support converting 'C++' maps 'R' lists, 'Roxygen' documentation directly 'C++' code, proper handling matrix attributes, support nullable external pointers, bidirectional copy complex number types, flexibility type conversions, use nullable pointers, various performance optimizations.","code":""},{"path":[]},{"path":"./reference/cpp4r-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"cpp4r: Header-Only 'C++' and 'R' Interface — cpp4r-package","text":"Maintainer: Mauricio Vargas Sepulveda m.vargas.sepulveda@gmail.com (ORCID) Authors: Posit Software, PBC (Original cpp11 package)","code":""},{"path":"./reference/pkg_template.html","id":null,"dir":"Reference","previous_headings":"","what":"Start a new project with the cpp4r package template — pkg_template","title":"Start a new project with the cpp4r package template — pkg_template","text":"Start new project cpp4r package template","code":""},{"path":"./reference/pkg_template.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Start a new project with the cpp4r package template — pkg_template","text":"","code":"pkg_template(path = NULL, pkgname = NULL)"},{"path":"./reference/pkg_template.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Start a new project with the cpp4r package template — pkg_template","text":"path Path new project pkgname Name new package","code":""},{"path":"./reference/pkg_template.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Start a new project with the cpp4r package template — pkg_template","text":"file path copied template (invisibly).","code":""},{"path":"./reference/pkg_template.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Start a new project with the cpp4r package template — pkg_template","text":"","code":"# create a new directory dir <- tempdir() dir.create(dir) #> Warning: '/tmp/RtmpzJBpQi' already exists  # copy the package template into the directory pkg_template(dir, \"mynewpkg\")"},{"path":"./reference/register.html","id":null,"dir":"Reference","previous_headings":"","what":"Generates wrappers for registered C++ functions — register","title":"Generates wrappers for registered C++ functions — register","text":"Functions decorated [[cpp4r::register]] files ending .cc, .cpp, .h .hpp wrapped generated code registered called R.","code":""},{"path":"./reference/register.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generates wrappers for registered C++ functions — register","text":"","code":"register(path = NULL, quiet = !is_interactive(), extension = c(\".cpp\", \".cc\"))"},{"path":"./reference/register.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generates wrappers for registered C++ functions — register","text":"path path package root directory. default NULL, quiet TRUE suppresses output function extension file extension use generated src/cpp4r file. .cpp default, .cc also supported.","code":""},{"path":"./reference/register.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generates wrappers for registered C++ functions — register","text":"paths generated R C++ source files (order).","code":""},{"path":"./reference/register.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generates wrappers for registered C++ functions — register","text":"Note registered functions exported package unless also add @export roxygen2 directive . order use register() cli, decor, desc, glue, tibble vctrs packages must also installed.","code":""},{"path":"./reference/register.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generates wrappers for registered C++ functions — register","text":"","code":"# create a minimal package dir <- tempfile() dir.create(dir)  writeLines(\"Package: testPkg\", file.path(dir, \"DESCRIPTION\")) writeLines(\"useDynLib(testPkg, .registration = TRUE)\", file.path(dir, \"NAMESPACE\"))  # create a C++ file with a decorated function dir.create(file.path(dir, \"src\")) writeLines(\"[[cpp4r::register]] int one() { return 1; }\", file.path(dir, \"src\", \"one.cpp\"))  # register the functions in the package register(dir)  # Files generated by registration file.exists(file.path(dir, \"R\", \"cpp4r.R\")) #> [1] TRUE file.exists(file.path(dir, \"src\", \"cpp4r.cpp\")) #> [1] TRUE  # cleanup unlink(dir, recursive = TRUE)"},{"path":"./reference/unvendor.html","id":null,"dir":"Reference","previous_headings":"","what":"Unvendor the cpp4r headers — unvendor","title":"Unvendor the cpp4r headers — unvendor","text":"function removes vendored cpp4r headers package automatically finding vendored headers.","code":""},{"path":"./reference/unvendor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unvendor the cpp4r headers — unvendor","text":"","code":"unvendor(path = NULL)"},{"path":"./reference/unvendor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unvendor the cpp4r headers — unvendor","text":"path directory vendored headers. recommended use \"./src/vendor\". default NULL.","code":""},{"path":"./reference/unvendor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unvendor the cpp4r headers — unvendor","text":"path unvendored code (invisibly).","code":""},{"path":"./reference/unvendor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unvendor the cpp4r headers — unvendor","text":"","code":"# create a new directory dir <- tempfile() dir.create(dir)  # vendor the cpp4r headers into the directory vendor(dir)  # unvendor the cpp4r headers from the directory unvendor(dir)  # cleanup unlink(dir, recursive = TRUE)"},{"path":"./reference/vendor.html","id":null,"dir":"Reference","previous_headings":"","what":"Vendor the cpp4r headers — vendor","title":"Vendor the cpp4r headers — vendor","text":"Vendoring act making copy 3rd party packages project using. often used go language community.","code":""},{"path":"./reference/vendor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vendor the cpp4r headers — vendor","text":"","code":"vendor(path = \"./src/vendor\")"},{"path":"./reference/vendor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vendor the cpp4r headers — vendor","text":"path directory vendor headers ","code":""},{"path":"./reference/vendor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vendor the cpp4r headers — vendor","text":"path vendored code (invisibly).","code":""},{"path":"./reference/vendor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vendor the cpp4r headers — vendor","text":"function vendors cpp4r package copying cpp4r headers inst/include folder package adding 'cpp4r version: XYZ' top files, XYZ version cpp4r currently installed machine. Note: vendoring places responsibility updating code . Bugfixes new features cpp4r available code run cpp_vendor() .","code":""},{"path":"./reference/vendor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vendor the cpp4r headers — vendor","text":"","code":"# create a new directory dir <- paste0(tempdir(), \"/\", gsub(\"\\\\s+|[[:punct:]]\", \"\", Sys.time())) dir.create(dir, recursive = TRUE)  # vendor the cpp4r headers into the directory vendor(dir)  list.files(file.path(dir, \"src\", \"vendor\")) #> character(0)  # cleanup unlink(dir, recursive = TRUE)"},{"path":"./news/index.html","id":"cpp4r-030","dir":"Changelog","previous_headings":"","what":"cpp4r 0.3.0","title":"cpp4r 0.3.0","text":"Added as_logicals() as_strings() style as_doubles() as_integers() Improved memory management r_vector iterators Slightly faster cpp11 vendor() unvendor() use path = NULL default adhere CRAN policies.","code":""},{"path":"./news/index.html","id":"cpp4r-020","dir":"Changelog","previous_headings":"","what":"cpp4r 0.2.0","title":"cpp4r 0.2.0","text":"Reduced dependencies R side vignettes rendered package site keep CRAN build minimal","code":""},{"path":"./news/index.html","id":"cpp4r-010","dir":"Changelog","previous_headings":"","what":"cpp4r 0.1.0","title":"cpp4r 0.1.0","text":"Initial release","code":""}]
