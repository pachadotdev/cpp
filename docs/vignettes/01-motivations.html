<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>01 - Motivations for cpp4r ‚Ä¢ cpp4r</title><link rel="stylesheet" href="../menu.css"><link rel="stylesheet" href="../content.css"><!-- MathJax Configuration --><script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)'], ['$', '$']],
        displayMath: [['\\[', '\\]'], ['$$', '$$']],
        processEscapes: true,
        processEnvironments: true,
        packages: {'[+]': ['ams', 'newcommand', 'configmacros']}
      },
      svg: {
        fontCache: 'global',
        scale: 1.5,  /* Scale SVG math to 150% */
        minScale: 0.5,
        mtextInheritFont: false,
        merrorInheritFont: true,
        mathmlSpacing: false,
        exFactor: 0.5  /* Adjust baseline for better alignment */
      },
      options: {
        ignoreHtmlClass: 'tex2jax_ignore',
        processHtmlClass: 'tex2jax_process'
      }
    };
  </script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script></head><body>
<div class="main-container">
<div id="menu">
  <div>
    <h1>cpp4r Documentation</h1>
  </div>

  <div class="search-container">
    <input type="text" id="search-box" placeholder="Search..."><button id="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">üí°</button>
  </div>

  <div class="submenu">
    <label style="border-bottom: 0;"><a style="padding-left: 0;" href="../index.html">Home üè†</a></label>
  </div>

  <div class="submenu">
    <label>Functions</label>
    <a href="../reference/cpp4r-package.html">cpp4r-package</a>
    <a href="../reference/pkg_template.html">pkg_template</a>
    <a href="../reference/register.html">register</a>
    <a href="../reference/unvendor.html">unvendor</a>
    <a href="../reference/vendor.html">vendor</a>
  </div>

  <div class="submenu">
    <label>Vignettes</label>
    <a href="../vignettes/01-motivations.html">01 - Motivations for cpp4r</a>
    <a href="../vignettes/02-setup.html">02 - Setup</a>
    <a href="../vignettes/03-package-skeleton.html">03 - Package Skeleton</a>
    <a href="../vignettes/04-read-only.html">04 - Read-only versus Writable R Objects</a>
    <a href="../vignettes/05-logical-functions.html">05 - Logical Functions</a>
    <a href="../vignettes/06-rolling-functions.html">06 - Rolling Functions</a>
    <a href="../vignettes/07-statistical-functions.html">07 - Statistical Functions</a>
    <a href="../vignettes/08-logical-functions-2.html">08 - Logical Functions with Missing Values</a>
    <a href="../vignettes/09-rolling-functions-2.html">09 - Rolling Functions with Missing Values</a>
    <a href="../vignettes/10-statistical-functions-2.html">10 - Statistical Functions with Missing Values</a>
    <a href="../vignettes/11-debugging.html">11 - Debugging R Packages</a>
    <a href="../vignettes/12-external-pointers.html">12 - External Pointers</a>
    <a href="../vignettes/13-compiler-optimization.html">13 - Compiler Optimizations</a>
    <a href="../vignettes/14-linear-algebra.html">14 - Linear Algebra</a>
    <a href="../vignettes/15-internals.html">15 - Internals</a>
    <a href="../vignettes/16-FAQ.html">17 - FAQs</a>
    <a href="../vignettes/17-worked-examples.html">16 - Worked Examples</a>
  </div>

  <div class="submenu">
    <label>News</label>
    <a href="../news/index.html">Changelog</a>
  </div>
</div>
<div id="content">
<div class="content-wrapper">
<div class="content-main">
<h1>01 - Motivations for cpp4r</h1>



<div id="motivation-and-significance" class="section level2">
<h2>Motivation and significance</h2>
<p>The R programming language has maintained a long-standing tradition
of interfacing with compiled languages, dating back to the original S
implementation in the late 1970s, which served primarily as a wrapper
around FORTRAN routines <span class="citation">(Chambers 2006)</span>.
This integration remains relevant today, as R code sometimes lacks the
performance needed for computationally intensive tasks. Even after
optimizing R code through vectorization and avoiding unnecessary object
copying, bottlenecks may persist that require compiled language
solutions.</p>
<p>C++ offers particular advantages for addressing common R performance
bottlenecks, including:</p>
<ul><li>Loops that cannot be easily vectorized due to dependencies between
iterations</li>
<li>Recursive functions or problems requiring many function calls</li>
<li>Data structures and algorithms not natively available in R (e.g., R
does not let the end-user use pointers and pass-by-reference
semantics)</li>
<li>Problems requiring fine-tuning memory management</li>
</ul><p>cpp4r is an R package that provides C++11 bindings to R, enabling the
use of C++ code in R packages. It is a fork of the cpp11 package <span class="citation">(Vaughan, Hester, and Fran√ßois 2025)</span> aiming to
provide additional features and improvements while maintaining
compatibility with the original cpp11 API.</p>
<p>The landscape of C++ bindings for R has evolved significantly over
the past two decades. The cxx package, released in 2000, provided an
early prototype of C++ bindings <span class="citation">(Hornik
2001)</span>. Rcpp, first published to CRAN in 2008, became the
mainstream solution with over 2,000 reverse dependencies by 2020 <span class="citation">(Eddelbuettel and Francois 2011)</span>. A subsequent
attempt, Rcpp11, was released in 2014 but did not achieve widespread
adoption <span class="citation">(Francois, Ushey, and Chambers
2020)</span>.</p>
<p>While Rcpp has been highly successful, adding modern C++ features or
addressing certain architectural issues would require substantial
breaking changes. These changes would compromise backward compatibility
with the extensive ecosystem of dependent packages.</p>
<p>To address these limitations, the cpp11 package <span class="citation">(Vaughan, Hester, and Fran√ßois 2023)</span> was
released in 2023 as a complete reimplementation of C++ bindings to R,
incorporating modern C++ features and different design trade-offs aiming
to provide:</p>
<ul><li>Enforced copy-on-write semantics consistent with R‚Äôs behavior</li>
<li>Improved safety when interfacing with R‚Äôs C API</li>
<li>Native support for ALTREP objects</li>
<li>UTF-8 string handling throughout</li>
<li>Modern C++11 features and idioms</li>
<li>Simplified implementation compared to Rcpp</li>
<li>Faster compilation with reduced memory requirements</li>
<li>Completely header-only design to avoid Application Binary Interface
(ABI) compatibility issues</li>
</ul></div>
<div id="software-description" class="section level1">
<h1>Software description</h1>
<p>While using cpp11 for my thesis project, I identified several
enhancements that could benefit the R community and improve the
library‚Äôs usability. These enhancements include:</p>
<ul><li>Support for converting C++ maps to R lists</li>
<li>Roxygen documentation support directly in C++ code</li>
<li>Proper handling of matrix attributes</li>
<li>Support for nullable external pointers</li>
<li>Immediate availability of values added via
<code>push_back()</code></li>
<li>Bidirectional copy of complex number types</li>
<li>Flexibility in type conversions</li>
<li>Various performance optimizations</li>
</ul><p>After discussing these proposed enhancements with the cpp11
maintainers, it became clear that the development priorities and
timelines would not accommodate these features in the near term. This
led to the creation of cpp4r, a fork of cpp11 that incorporates these
additional features while maintaining compatibility with the original
cpp11 API. This means that cpp4r can serve as a drop-in replacement for
cpp11 in any case, allowing users to benefit from the enhancements
without significant code changes. The converse, replacing cpp4r with
cpp11, requires adjustments due to the additional features in cpp4r.</p>
<p>cpp4r extends cpp11‚Äôs container support by enabling seamless
conversion between C++ standard library containers and R objects. This
includes support for <code>std::map</code> and
<code>std::unordered_map</code> containers, which are automatically
converted to named R lists.</p>
<p>cpp4r provides roxygen support directly in C++ code, allowing
developers to document their C++ functions using familiar roxygen2
syntax. This integration streamlines the documentation workflow for
packages that expose C++ functions to R.</p>
<p>Unlike cpp11, cpp4r properly handles matrix attributes, including
<code>dimnames</code>, ensuring that matrix operations preserve metadata
when copying data between R and C++.</p>
<p>cpp4r offers more flexible type conversion functions. For example,
<code>as_integers()</code> and <code>as_doubles()</code> accept logical
inputs, providing greater flexibility in handling diverse input types
compared to the more restrictive cpp11 implementations.</p>
<p>Several internal optimizations improve performance over cpp11,
particularly in vector operations and memory management. These
optimizations maintain the safety guarantees of cpp11 while improving
execution speed.</p>
<p>cpp4r provides full bidirectional copying of complex numbers,
enabling seamless transfer of complex vectors and matrices between R and
C++ code. In contrast, cpp11 does not support this functionality.</p>
<p>cpp4r maintains cpp11‚Äôs core design principles while extending
functionality:</p>
<ul><li>Copy-on-Write Semantics: Like cpp11, cpp4r enforces copy-on-write
semantics that match R‚Äôs behavior, preventing unexpected modifications
to input data.</li>
<li>Safety First: cpp4r incorporates comprehensive safety mechanisms
when interfacing with R‚Äôs C API, using <code>unwind_protect()</code> and
exception handling to prevent resource leaks.</li>
<li>Modern C++ Features: The implementation leverages C++11 features
including move semantics, type traits, variadic templates, and
user-defined literals.</li>
<li>Header-Only Design: As a completely header-only library, cpp4r
avoids ABI compatibility issues that can arise with libraries containing
compiled components.</li>
</ul><p>cpp4r offers vendoring capabilities, which means copying the
dependency code directly into your project‚Äôs source tree. This approach,
borrowed from the Go programming language, includes the dependencies‚Äô
headers with the source code <span class="citation">(The Go Authors
2024)</span>. This ensures the dependency code remains fixed and stable
until explicitly updated. Since cpp4r is a header-only library, you can
copy all headers by running <code>cpp4r::vendor_cpp4r()</code> when
needed.</p>
<p>Vendoring has both advantages and drawbacks. The main advantage is
that disruptive changes to the cpp4r project cannot break your existing
code. The drawbacks include slightly larger package size and isolation
from bugfixes and new features until you explicitly update the vendored
headers. Most packages should not vendor the cpp4r dependency, except
for projects designed to run in restricted environments where internet
access is limited or unavailable for security reasons (e.g.,
high-performance computing clusters).</p>
</div>
<div id="software-functionalities" class="section level1">
<h1>Software functionalities</h1>
<p>cpp4r is designed as a drop-in replacement for cpp11, using identical
syntax and API patterns. Existing cpp11 code can typically be migrated
to cpp4r with minimal changes, primarily involving header includes and
namespace references.</p>
<p>To use cpp4r, users must first install the package from CRAN or
GitHub. The following code shows how to install the package:</p>
<pre class="r"><code>install.packages("cpp4r", repos = "https://cran.rstudio.com")

# or
remotes::install_github("pachadotdev/cpp4r")</code></pre>
<p>Once installed, users can use the provided package template function
to create a new package that uses C++ code. The package template
includes simple examples and all the necessary files to compile the code
and install the new R package. The following code shows how to create a
new package:</p>
<pre class="r"><code>cpp4r::pkg_template("~/rstats/mypkg")</code></pre>
<p>The package skeleton includes standard practices:</p>
<pre class="r"><code># In DESCRIPTION file
LinkingTo: cpp4r

# In R code
#' @useDynLib mypkg, .registration = TRUE
#' @keywords internal
"_PACKAGE"</code></pre>
<p>C++ functions are exposed to R using the attribute syntax and
documented with roxygen comments:</p>
<pre class="cpp"><code>/* roxygen
@title Square of Each Element in 'x'
@param x Numeric vector
@return Numeric vector
@export
*/
[[cpp4r::register]]
cpp4r::doubles my_square(cpp4r::doubles x) {
  return x * x;
}</code></pre>
<p>The equivalent cpp11 code would be:</p>
<pre class="cpp"><code>[[cpp11::register]]
cpp11::doubles my_square_cpp(cpp11::doubles x) {
  return x * x;
}</code></pre>
<pre class="r"><code>#' @title Square of Each Element in 'x'
#' @param x Numeric vector
#' @return Numeric vector
#' @export
my_square &lt;- function(x) {
  my_square_cpp(x)
}</code></pre>
</div>
<div id="illustrative-examples" class="section level1">
<h1>Illustrative examples</h1>
<p>cpp4r uses lists to track managed objects. This approach is more
efficient for large numbers of objects than Rcpp‚Äôs use of
<code>R_PreserveObject()</code>/<code>R_ReleaseObjects()</code>.</p>
<p>When vector or matrix sizes are known beforehand, the performance
difference between cpp4r/cpp11 and Rcpp is negligible. However, when the
length is unknown beforehand, performance changes notably. This is the
case with rejection sampling algorithms, which obtain <span class="math inline">\(n\)</span> accepted samples without knowing in
advance how many candidates need to be generated.</p>
<p>The C++ <code>push_back()</code> method is ideal for rejection
sampling, where each candidate is either accepted (stored) or rejected
(discarded). With low acceptance rates, we might need to generate <span class="math inline">\(kn\)</span> candidates (<span class="math inline">\(k &gt; 1\)</span>) to obtain <span class="math inline">\(n\)</span> final samples. Unlike Gibbs sampling
algorithms, where iterations are known upfront, rejection sampling
requires dynamically growing vectors or matrices. For example, with an
80% acceptance rate, we need to generate approximately <span class="math inline">\(1.25n\)</span> samples to obtain <span class="math inline">\(n\)</span> final samples.</p>
<p>Rejection sampling is used in Monte Carlo methods, Bayesian
inference, and simulation studies where cpp4r‚Äôs design is advantageous
because it reserves extra memory, making <code>push_back()</code>
operations have <span class="math inline">\(O(1)\)</span> time
complexity. In contrast, Rcpp does not reserve extra capacity, and its
<code>push_back()</code> operations have <span class="math inline">\(O(n)\)</span> time complexity, leading to
quadratic memory usage patterns. This design difference translates to
performance differences with larger input data.</p>
<p>The following code shows a rejection sampling implementation with
lower and upper truncation bounds using cpp4r. The syntax is equivalent
for cpp11 and Rcpp, but performance differs:</p>
<pre class="cpp"><code>// Reproducible examples via set.seed() in R
class local_rng {
 public:
  local_rng() { GetRNGstate(); }
  ~local_rng() { PutRNGstate(); }
};

[[cpp4r::register]]
doubles rejection_sampling(int n_samples, double mu = 0.0, double sigma = 1.0,
                           double lower = -2.0, double upper = 2.0) {
  local_rng rng_state;

  // Acceptance rate for better initial allocation
  double z_lower = (lower - mu) / sigma, z_upper = (upper - mu) / sigma;
  double acceptance_rate = Rf_pnorm5(z_upper, 0.0, 1.0, 1, 0) -
    Rf_pnorm5(z_lower, 0.0, 1.0, 1, 0);

  // Allocate based on expected number of samples needed
  // (add 20% to ensure minimum size)
  R_xlen_t estimated_needed = static_cast&lt;R_xlen_t&gt;(n_samples / acceptance_rate * 1.2);
  estimated_needed = std::max(estimated_needed, static_cast&lt;R_xlen_t&gt;(n_samples));

  writable::doubles accepted_samples;
  accepted_samples.reserve(estimated_needed);

  // Keep sampling until we have enough accepted samples
  int target_samples = static_cast&lt;int&gt;(n_samples);

  while (static_cast&lt;int&gt;(accepted_samples.size()) &lt; target_samples) {
    double candidate = Rf_rnorm(mu, sigma);

    if (candidate &gt;= lower &amp;&amp; candidate &lt;= upper) {
      accepted_samples.push_back(candidate);
    }
  }

  return accepted_samples;
}</code></pre>
<p>The following table shows the speed quantiles for the same rejection
sampling algorithm implemented with cpp4r, cpp11, and Rcpp:</p>
<table class="table" style="margin-left: auto; margin-right: auto;"><thead><tr><th style="text-align:left;">
Backend
</th>
<th style="text-align:right;">
Sample size
</th>
<th style="text-align:right;">
Median speed
</th>
<th style="text-align:right;">
Cumulative memory usage
</th>
</tr></thead><tbody><tr><td style="text-align:left;vertical-align: middle !important;" rowspan="4">
cpp4r
</td>
<td style="text-align:right;">
25,000
</td>
<td style="text-align:right;">
808.53¬µs
</td>
<td style="text-align:right;">
468.96KB
</td>
</tr><tr><td style="text-align:right;">
50,000
</td>
<td style="text-align:right;">
2.17ms
</td>
<td style="text-align:right;">
931.76KB
</td>
</tr><tr><td style="text-align:right;">
75,000
</td>
<td style="text-align:right;">
2.75ms
</td>
<td style="text-align:right;">
1.36MB
</td>
</tr><tr><td style="text-align:right;">
100,000
</td>
<td style="text-align:right;">
3.57ms
</td>
<td style="text-align:right;">
1.82MB
</td>
</tr><tr><td style="text-align:left;vertical-align: middle !important;" rowspan="4">
cpp11
</td>
<td style="text-align:right;">
25,000
</td>
<td style="text-align:right;">
806.16¬µs
</td>
<td style="text-align:right;">
714.71KB
</td>
</tr><tr><td style="text-align:right;">
50,000
</td>
<td style="text-align:right;">
2.6ms
</td>
<td style="text-align:right;">
1.38MB
</td>
</tr><tr><td style="text-align:right;">
75,000
</td>
<td style="text-align:right;">
2.77ms
</td>
<td style="text-align:right;">
2.57MB
</td>
</tr><tr><td style="text-align:right;">
100,000
</td>
<td style="text-align:right;">
3.98ms
</td>
<td style="text-align:right;">
2.76MB
</td>
</tr><tr><td style="text-align:left;vertical-align: middle !important;" rowspan="4">
Rcpp
</td>
<td style="text-align:right;">
25,000
</td>
<td style="text-align:right;">
420.98ms
</td>
<td style="text-align:right;">
2.33GB
</td>
</tr><tr><td style="text-align:right;">
50,000
</td>
<td style="text-align:right;">
1.52s
</td>
<td style="text-align:right;">
9.32GB
</td>
</tr><tr><td style="text-align:right;">
75,000
</td>
<td style="text-align:right;">
4.04s
</td>
<td style="text-align:right;">
20.96GB
</td>
</tr><tr><td style="text-align:right;">
100,000
</td>
<td style="text-align:right;">
6.01s
</td>
<td style="text-align:right;">
37.26GB
</td>
</tr></tbody></table><p>The benchmark shows that both cpp4r and cpp11 scale better than Rcpp
when making repeated <code>push_back()</code> calls. With Rcpp, the
entire vector must be copied on each call. In contrast, cpp4r vectors
grow efficiently by reserving extra space, similar to
<code>std::vector</code>.</p>
<p>The benchmark followed the guidelines from <span class="citation">Beyer, L√∂we, and Wendler (2019)</span>. It was
conducted on a Lenovo ThinkPad X1 Carbon Gen 9 laptop equipped with an
11th Gen Intel Core i7-1185G7 processor (8 cores, 3.00GHz), 15.3 GiB of
RAM and Manjaro Linux operating system.</p>
</div>
<div id="impact" class="section level1">
<h1>Impact</h1>
<p>By providing a portable interface for C++ integration, cpp4r enables
R developers to leverage the power of modern C++ while minimizing the
complexity typically associated with writing compiled code. The
benchmarks demonstrate substantial speed and memory usage improvements
compared to existing implementations, providing researchers with a
useful tool to write R packages to analyze large datasets and intensive
computations.</p>
<p>Beyond improved memory usage, which can determine whether an analysis
is feasible, cpp4r‚Äôs design also offers faster compilation times,
enhancing development workflow and testing. This is particularly
beneficial in academic and business settings, where prototyping and
iteration are common before final implementation.</p>
<p>cpp4r represents an evolution in C++ bindings for R, building upon
the solid foundation established by cpp11 while addressing specific
limitations and adding features that can benefit the R community. By
maintaining API compatibility with cpp11, cpp4r provides a migration
path for developers seeking enhanced functionality without requiring
significant code restructuring.</p>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>The development of cpp4r demonstrates the value of open-source
transparency and how it enables derived works. While cpp11 and Rcpp
continue to serve the broader R community effectively, cpp4r offers an
alternative for projects requiring its specific enhancements,
particularly in academic research contexts where documentation features
and additional data types support reduce the coding effort for advancing
computational methods.</p>
<p>The software, documentation, and replication code are available on <a href="https://github.com/pachadotdev/cpp4r">GitHub</a>. The codebase is
released under the Apache 2.0 license. Contributions and feedback from
the R community are welcome to help improve the package further. We hope
that cpp4r will be a valuable tool for R developers, providing a simple
solution for performance bottlenecks by integrating C++ code into R
packages.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">references</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-beyer19" class="csl-entry">
Beyer, Dirk, Stefan L√∂we, and Philipp Wendler. 2019. <span>‚ÄúReliable
Benchmarking: Requirements and Solutions.‚Äù</span> <em>International
Journal on Software Tools for Technology Transfer</em> 21 (1): 1‚Äì29. <a href="https://doi.org/10.1007/s10009-017-0469-y">https://doi.org/10.1007/s10009-017-0469-y</a>.
</div>
<div id="ref-chambers06" class="csl-entry">
Chambers, John. 2006. <span>‚ÄúA <span>History</span> of <span>S</span>
and <span>R</span> (with Some Questions for the Future).‚Äù</span> Vienna,
Austria. <a href="https://www.r-project.org/conferences/useR-2006/Presentations/index.html">https://www.r-project.org/conferences/useR-2006/Presentations/index.html</a>.
</div>
<div id="ref-eddelbuettel11" class="csl-entry">
Eddelbuettel, Dirk, and Romain Francois. 2011. <span>‚ÄúRcpp:
<span>Seamless</span> <span>R</span> and <span>C++</span>
<span>Integration</span>.‚Äù</span> <em>Journal of Statistical
Software</em> 40 (April): 1‚Äì18. <a href="https://doi.org/10.18637/jss.v040.i08">https://doi.org/10.18637/jss.v040.i08</a>.
</div>
<div id="ref-francois20" class="csl-entry">
Francois, Romain, Kevin Ushey, and John Chambers. 2020. <span>‚ÄúRcpp11:
<span>R</span> and <span>C</span>++11.‚Äù</span> <a href="https://cran.r-project.org/web/packages/Rcpp11/index.html">https://cran.r-project.org/web/packages/Rcpp11/index.html</a>.
</div>
<div id="ref-hornik01" class="csl-entry">
Hornik, Kurt. 2001. <span>‚ÄúCxx: <span>C</span>++ Test.‚Äù</span> <a href="https://cran.r-project.org/src/contrib/Archive/cxx/">https://cran.r-project.org/src/contrib/Archive/cxx/</a>.
</div>
<div id="ref-go24" class="csl-entry">
The Go Authors. 2024. <span>‚ÄúGo <span>Modules</span>
<span>Reference</span>.‚Äù</span> <a href="https://go.dev/ref/mod">https://go.dev/ref/mod</a>.
</div>
<div id="ref-cpp1123" class="csl-entry">
Vaughan, Davis, Jim Hester, and Romain Fran√ßois. 2023. <em>‚ÄòCpp11‚Äò: A
<span>C++</span>11 Interface for <span>R</span>‚Äôs c Interface</em>. <a href="https://CRAN.R-project.org/package=cpp11">https://CRAN.R-project.org/package=cpp11</a>.
</div>
<div id="ref-cpp1125" class="csl-entry">
‚Äî‚Äî‚Äî. 2025. <em>‚ÄòCpp11‚Äò: A <span>C++</span>11 Interface for
<span>R</span>‚Äôs c Interface</em>. <a href="https://CRAN.R-project.org/package=cpp11">https://CRAN.R-project.org/package=cpp11</a>.
</div>
</div>
</div>
</div>
<footer><p>Last updated: 2025-10-12 11:32:40</p>
</footer><script>
document.addEventListener('DOMContentLoaded', function() {
  // Theme toggle functionality
  const themeToggle = document.getElementById('theme-toggle');
  const currentTheme = localStorage.getItem('theme') || 'light';

  // Apply saved theme
  document.documentElement.setAttribute('data-theme', currentTheme);

  if (themeToggle) {
    themeToggle.addEventListener('click', function() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
    });
  }

  // Search functionality
  const searchBox = document.getElementById('search-box');
  if (!searchBox) return;

  let searchIndex = [];

  // Load search index
  fetch('../search.json')
    .then(response => response.json())
    .then(data => {
      searchIndex = data;
    })
    .catch(error => {
      console.log('Search index not available, falling back to simple search');
    });

  searchBox.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase().trim();

    if (searchTerm === '') {
      // Show all items when search is empty
      document.querySelectorAll('#menu .submenu a').forEach(function(link) {
        link.style.display = 'block';
      });
      document.querySelectorAll('#menu .submenu').forEach(function(submenu) {
        submenu.style.display = 'block';
      });
      return;
    }

    // Content-based search using search index
    if (searchIndex.length > 0) {
      const matchingUrls = new Set();

      searchIndex.forEach(function(item) {
        const searchContent = (item.title + ' ' + item.content).toLowerCase();
        if (searchContent.includes(searchTerm)) {
          matchingUrls.add(item.url);
        }
      });

      // Show/hide links based on content matches
      document.querySelectorAll('#menu .submenu a').forEach(function(link) {
        const href = link.getAttribute('href');
        const relativePath = href.replace(/^.*\//, ''); // Get just the filename part

        let isMatch = false;
        matchingUrls.forEach(function(url) {
          if (url.includes(relativePath)) {
            isMatch = true;
          }
        });

        // Also check link text for simple matches
        if (!isMatch && link.textContent.toLowerCase().includes(searchTerm)) {
          isMatch = true;
        }

        link.style.display = isMatch ? 'block' : 'none';
      });
    } else {
      // Fallback to simple name-based search
      document.querySelectorAll('#menu .submenu a').forEach(function(link) {
        const linkText = link.textContent.toLowerCase();
        link.style.display = linkText.includes(searchTerm) ? 'block' : 'none';
      });
    }

    // Show/hide entire submenus if no visible links
    document.querySelectorAll('#menu .submenu').forEach(function(submenu) {
      const visibleLinks = submenu.querySelectorAll('a[style*="display: block"]');
      const label = submenu.querySelector('label');

      // Don't hide the Home submenu
      if (label && label.textContent.includes('Home')) {
        return;
      }

      submenu.style.display = visibleLinks.length > 0 ? 'block' : 'none';
    });
  });
});
</script></div>
</div>
</div>
</body></html>

