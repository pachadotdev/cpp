<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>05 - Logical Functions ‚Ä¢ cpp4r</title><link rel="stylesheet" href="../menu.css"><link rel="stylesheet" href="../content.css"></head><body>
<div class="main-container">
<div id="menu">
  <div>
    <h1>cpp4r Documentation</h1>
  </div>

  <div class="search-container">
    <input type="text" id="search-box" placeholder="Search..."><button id="theme-toggle" title="Toggle dark mode" aria-label="Toggle dark mode">üí°</button>
  </div>

  <div class="submenu">
    <label style="border-bottom: 0;"><a style="padding-left: 0;" href="../index.html">Home üè†</a></label>
  </div>

  <div class="submenu">
    <label>Functions</label>
    <a href="../reference/cpp4r-package.html">cpp4r-package</a>
    <a href="../reference/pkg_template.html">pkg_template</a>
    <a href="../reference/register.html">register</a>
    <a href="../reference/unvendor.html">unvendor</a>
    <a href="../reference/vendor.html">vendor</a>
  </div>

  <div class="submenu">
    <label>Vignettes</label>
    <a href="../vignettes/01-motivations.html">01 - Motivations for cpp4r</a>
    <a href="../vignettes/02-setup.html">02 - Setup</a>
    <a href="../vignettes/03-package-skeleton.html">03 - Package Skeleton</a>
    <a href="../vignettes/04-read-only.html">04 - Read-only versus Writable R Objects</a>
    <a href="../vignettes/05-logical-functions.html">05 - Logical Functions</a>
    <a href="../vignettes/06-rolling-functions.html">06 - Rolling Functions</a>
    <a href="../vignettes/07-statistical-functions.html">07 - Statistical Functions</a>
    <a href="../vignettes/08-logical-functions-2.html">08 - Logical Functions with Missing Values</a>
    <a href="../vignettes/09-rolling-functions-2.html">09 - Rolling Functions with Missing Values</a>
    <a href="../vignettes/10-statistical-functions-2.html">10 - Statistical Functions with Missing Values</a>
    <a href="../vignettes/11-debugging.html">11 - Debugging R Packages</a>
    <a href="../vignettes/12-external-pointers.html">12 - External Pointers</a>
    <a href="../vignettes/13-compiler-optimization.html">13 - Compiler Optimizations</a>
    <a href="../vignettes/14-linear-algebra.html">14 - Linear Algebra</a>
    <a href="../vignettes/15-internals.html">15 - Internals</a>
    <a href="../vignettes/16-FAQ.html">17 - FAQs</a>
    <a href="../vignettes/17-worked-examples.html">16 - Worked Examples</a>
  </div>

</div>
<div id="content">
<h1>05 - Logical Functions</h1>



<p>These examples were adapted from <span class="citation">Vaughan,
Hester, and Francois (2024)</span>.</p>
<div id="note" class="section level1">
<h1>Note</h1>
<p>These functions ignore <code>NA</code> values for now. Adjustments
for handling <code>NA</code> values are covered in a separate
vignette.</p>
<p>R already provides efficient versions of the functions covered here.
This is just to illustrate how to use C++ code.</p>
</div>
<div id="is-any-value-in-a-vector-true" class="section level1">
<h1>Is any value in a vector ‚Äòtrue‚Äô?</h1>
<p>Base R‚Äôs <code>any()</code> function returns <code>TRUE</code> if
there is at least one <code>TRUE</code> element in a vector, and
<code>FALSE</code> otherwise. Below is one possible C++
implementation:</p>
<pre class="cpp"><code>[[cpp4r::register]]
bool any_cpp(logicals x) {
  int n = x.size();

  for (int i = 0; i &lt; n; ++i) {
    if (x[i]) {
      return true;
    }
  }
  return false;
}</code></pre>
<p>Its R equivalent would be:</p>
<pre class="r"><code>any_r &lt;- function(x) {
  n &lt;- length(x)

  for (i in 1:n) {
    if (x[i]) {
      return(TRUE)
    }
  }
  FALSE
}</code></pre>
<p>Add and document the functions, update the package as in the previous
vignettes, and then compare the functions speed with:</p>
<pre class="r"><code># install.packages("bench")
library(bench)

set.seed(123) # for reproducibility
x &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements
y &lt;- ifelse(x &gt; 2, TRUE, FALSE)

any(y)
any_cpp(y)
any_r(y)

mark(
  any(y),
  any_cpp(y),
  any_r(y)
)</code></pre>
</div>
<div id="which-elements-in-a-vector-are-true" class="section level1">
<h1>Which elements in a vector are ‚Äòtrue‚Äô?</h1>
<p>Base R‚Äôs <code>which()</code> function returns the indices of the
<code>TRUE</code> elements in a vector. Here is a possible C++
implementation:</p>
<pre class="cpp"><code>[[cpp4r::register]]
integers which_cpp(logicals x) {
  int n = x.size();
  writable::integers res;
  int j = 0;

  for (int i = 0; i &lt; n; ++i) {
    if (x[i]) {
      ++j;
      res.push_back(i + 1);
    }
  }

  if (j == 0) {
    return integers(0);
  } else {
    return res;
  }
}</code></pre>
<p>Its R equivalent would be:</p>
<pre class="r"><code>which_r &lt;- function(x) {
  n &lt;- length(x)
  res &lt;- c()
  j &lt;- 0

  for (i in 1:n) {
    if (x[i]) {
      res &lt;- c(res, i)
      j &lt;- j + 1
    }
  }

  if (j == 0) {
    return(0)
  } else {
    return(res)
  }
}</code></pre>
<p>To test the functions, you can run the following benchmark code in
the R console:</p>
<pre class="r"><code>which(y[1:100])
which_cpp(y[1:100])
which_r(y[1:100])

mark(
  which(y[1:1000]),
  which_cpp(y[1:1000]),
  which_r(y[1:1000])
)</code></pre>
</div>
<div id="are-all-values-in-a-vector-true" class="section level1">
<h1>Are all values in a vector ‚Äòtrue‚Äô?</h1>
<p>Base R‚Äôs <code>all()</code> function checks if all elements in a
vector are <code>TRUE</code>. Here is a possible C++ implementation that
loops over the vector:</p>
<pre class="cpp"><code>[[cpp4r::register]]
bool all_cpp_1(logicals x) {
  int n = x.size();
  for (int i = 0; i &lt; n; ++i) {
    if (!x[i]) {
      return false;
    }
  }
  return true;
}</code></pre>
<p>More concise C++ alternatives are:</p>
<pre class="cpp"><code>[[cpp4r::register]]
bool all_cpp_2(logicals x) {
  for (int i = 0; i &lt; x.size(); ++i) {
    if (!x[i]) {
      return false;
    }
  }
  return true;
}

[[cpp4r::register]] bool
all_cpp_3(logicals x) {
  for (bool i : x) {
    if (!i) {
      return false;
    }
  }
  return true;
}

[[cpp4r::register]] bool
all_cpp_4(logicals x) {
  return std::all_of(x.begin(), x.end(), [](bool x) { return x; });
}</code></pre>
<p>To avoid typing <code>std::</code> every time, you can use
<code>using namespace std;</code> at the top of
<code>src/code.cpp</code>. However, this is not recommended because it
can lead to conflicts. A better option is to declare
<code>using std::the_function;</code> which means you can use
<code>the_function</code> instead of <code>std::the_function</code> each
time <span class="citation">(Biggs 2024)</span>. However, this is not
recommended as it can lead to conflicts if two functions have the same
name.</p>
<p>To test the functions, you can run the following tests and benchmark
code in the R console:</p>
<pre class="r"><code>set.seed(123) # for reproducibility
x &lt;- rpois(1e6, lambda = 2) # 1,000,000 elements

all(x &gt; 2)
all_cpp_1(x &gt; 2)
all_cpp_2(x &gt; 2)
all_cpp_3(x &gt; 2)
all_cpp_4(x &gt; 2)

# also test the TRUE-only case
all(x &gt;= 0)
all_cpp_1(x &gt;= 0)
all_cpp_2(x &gt;= 0)
all_cpp_3(x &gt;= 0)
all_cpp_4(x &gt;= 0)</code></pre>
<pre class="r"><code>mark(
  all(x &gt; 2),
  all_cpp_1(x &gt; 2),
  all_cpp_2(x &gt; 2),
  all_cpp_3(x &gt; 2),
  all_cpp_4(x &gt; 2)
)</code></pre>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-akbiggs24" class="csl-entry">
Biggs, A.K. 2024. <span>‚ÄúWhat‚Äôs the Problem with "Using Namespace
Std;"?‚Äù</span> Forum post. <em>Stack Overflow</em>. <a href="https://stackoverflow.com/q/1452721/3720258">https://stackoverflow.com/q/1452721/3720258</a>.
</div>
<div id="ref-vaughan24" class="csl-entry">
Vaughan, Davis, Jim Hester, and Roman Francois. 2024. <span>‚ÄúGet Started
with Cpp11.‚Äù</span> <a href="https://cpp11.r-lib.org/articles/cpp11.html#intro">https://cpp11.r-lib.org/articles/cpp11.html#intro</a>.
</div>
</div>
</div>
<footer><p>Last updated: 2025-10-12 10:17:44</p>
</footer><script>
document.addEventListener('DOMContentLoaded', function() {
  // Theme toggle functionality
  const themeToggle = document.getElementById('theme-toggle');
  const currentTheme = localStorage.getItem('theme') || 'light';

  // Apply saved theme
  document.documentElement.setAttribute('data-theme', currentTheme);

  if (themeToggle) {
    themeToggle.addEventListener('click', function() {
      const currentTheme = document.documentElement.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

      document.documentElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
    });
  }

  // Search functionality
  const searchBox = document.getElementById('search-box');
  if (!searchBox) return;

  let searchIndex = [];

  // Load search index
  fetch('../search.json')
    .then(response => response.json())
    .then(data => {
      searchIndex = data;
    })
    .catch(error => {
      console.log('Search index not available, falling back to simple search');
    });

  searchBox.addEventListener('input', function() {
    const searchTerm = this.value.toLowerCase().trim();

    if (searchTerm === '') {
      // Show all items when search is empty
      document.querySelectorAll('#menu .submenu a').forEach(function(link) {
        link.style.display = 'block';
      });
      document.querySelectorAll('#menu .submenu').forEach(function(submenu) {
        submenu.style.display = 'block';
      });
      return;
    }

    // Content-based search using search index
    if (searchIndex.length > 0) {
      const matchingUrls = new Set();

      searchIndex.forEach(function(item) {
        const searchContent = (item.title + ' ' + item.content).toLowerCase();
        if (searchContent.includes(searchTerm)) {
          matchingUrls.add(item.url);
        }
      });

      // Show/hide links based on content matches
      document.querySelectorAll('#menu .submenu a').forEach(function(link) {
        const href = link.getAttribute('href');
        const relativePath = href.replace(/^.*\//, ''); // Get just the filename part

        let isMatch = false;
        matchingUrls.forEach(function(url) {
          if (url.includes(relativePath)) {
            isMatch = true;
          }
        });

        // Also check link text for simple matches
        if (!isMatch && link.textContent.toLowerCase().includes(searchTerm)) {
          isMatch = true;
        }

        link.style.display = isMatch ? 'block' : 'none';
      });
    } else {
      // Fallback to simple name-based search
      document.querySelectorAll('#menu .submenu a').forEach(function(link) {
        const linkText = link.textContent.toLowerCase();
        link.style.display = linkText.includes(searchTerm) ? 'block' : 'none';
      });
    }

    // Show/hide entire submenus if no visible links
    document.querySelectorAll('#menu .submenu').forEach(function(submenu) {
      const visibleLinks = submenu.querySelectorAll('a[style*="display: block"]');
      const label = submenu.querySelector('label');

      // Don't hide the Home submenu
      if (label && label.textContent.includes('Home')) {
        return;
      }

      submenu.style.display = visibleLinks.length > 0 ? 'block' : 'none';
    });
  });
});
</script></div>
</div>
</body></html>

