# get_call_entries: returns an empty string for packages with .Call entries and NAMESPACE files

    Code
      call_entries
    Output
      [1] "/* .Call calls */"                             
      [2] "extern SEXP bar(void);"                        
      [3] ""                                              
      [4] "static const R_CallMethodDef CallEntries[] = {"
      [5] "    {\"bar\", (DL_FUNC) &bar, 0},"             
      [6] "    {NULL, NULL, 0}"                           
      [7] "};"                                            

# get_call_entries: works with multiple register functions.

    Code
      cat(read_file(cpp_bindings))
    Output
      // Generated by cpp4r: do not edit by hand
      // clang-format off
      
      
      #include "cpp4r/declarations.hpp"
      #include <R_ext/Visibility.h>
      
      // multiple.cpp
      int foo();
      extern "C" SEXP _testPkg_foo() {
        BEGIN_CPP4R
          return cpp4r::as_sexp(foo());
        END_CPP4R
      }
      // multiple.cpp
      double bar(bool run);
      extern "C" SEXP _testPkg_bar(SEXP run) {
        BEGIN_CPP4R
          return cpp4r::as_sexp(bar(cpp4r::as_cpp<cpp4r::decay_t<bool>>(run)));
        END_CPP4R
      }
      // multiple.cpp
      bool baz(bool run, int value);
      extern "C" SEXP _testPkg_baz(SEXP run, SEXP value) {
        BEGIN_CPP4R
          return cpp4r::as_sexp(baz(cpp4r::as_cpp<cpp4r::decay_t<bool>>(run), cpp4r::as_cpp<cpp4r::decay_t<int>>(value)));
        END_CPP4R
      }
      
      extern "C" {
      static const R_CallMethodDef CallEntries[] = {
          {"_testPkg_bar", (DL_FUNC) &_testPkg_bar, 1},
          {"_testPkg_baz", (DL_FUNC) &_testPkg_baz, 2},
          {"_testPkg_foo", (DL_FUNC) &_testPkg_foo, 0},
          {NULL, NULL, 0}
      };
      }
      
      extern "C" attribute_visible void R_init_testPkg(DllInfo* dll){
        R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
        R_useDynamicSymbols(dll, FALSE);
        R_forceSymbols(dll, TRUE);
      }

# register: works with a package that registers a single c++ function

    Code
      cat(read_file(r_bindings))
    Output
      # Generated by cpp4r: do not edit by hand
      
      foo <- function() {
        .Call(`_testPkg_foo`)
      }

---

    Code
      cat(read_file(cpp_bindings))
    Output
      // Generated by cpp4r: do not edit by hand
      // clang-format off
      
      
      #include "cpp4r/declarations.hpp"
      #include <R_ext/Visibility.h>
      
      // single.cpp
      int foo();
      extern "C" SEXP _testPkg_foo() {
        BEGIN_CPP4R
          return cpp4r::as_sexp(foo());
        END_CPP4R
      }
      
      extern "C" {
      static const R_CallMethodDef CallEntries[] = {
          {"_testPkg_foo", (DL_FUNC) &_testPkg_foo, 0},
          {NULL, NULL, 0}
      };
      }
      
      extern "C" attribute_visible void R_init_testPkg(DllInfo* dll){
        R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
        R_useDynamicSymbols(dll, FALSE);
        R_forceSymbols(dll, TRUE);
      }

# register: can be run with messages

    Code
      register(p, quiet = FALSE)
    Message
      i 1 functions decorated with [[cpp4r::register]]
      v generated file 'cpp4r.R'
      v generated file 'cpp4r.cpp'

